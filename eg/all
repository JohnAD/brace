!)@(#*$&%^ ./colour/dither
#!/lang/b
use b
Main()
	space(600, 600)
	for(x, -300, 300, 1)
		int o = mod(x, 16) / 2
		for(y, -300-o, 300+o+1, 1)
			int p = mod(y, 16) / 2
			if (o+p) % 2 == 0
				rgb(0, 1, 0)
			 else
				rgb(1, 0, 0)
			point(x, y)
		Paint()
!)@(#*$&%^ ./colour/pink
#!/lang/b
use b

Main()
	int size
	num s0, s1, v0, v1
	
	size = atoi(Getenv("size", "100"))

	which args
	0	s0 = s1 = 1
		v0 = 0 ; v1 = 1
	4	s0 = atof(arg[0]) ; s1 = atof(arg[1])
		v0 = atof(arg[2]) ; v1 = atof(arg[3])

	space(size, size)
#	hsv_init()
	
	num r = min(w_2, h_2) - 10

	for(x, -w_2, w_2)
		for(y, -h_2, h_2)
			num a = Atan2(x, y)
			num i = hypot(x, y) / r
			
#			if !tween(a, -120, 120) && i<=1
			
			num s = i*(s1-s0) + s0
			num v = i*(v1-v0) + v0
			hsv(a, s, v)
		
			point(x, y)
		Paint()

Def trig_unit lun
 # todo, make it angle_unit ?

use lib_extra.b
!)@(#*$&%^ ./colour/pink_old
#!/lang/b
use b

Main()
	int size
	num s0, s1, v0, v1
	
	if args % 4 == 0
		size = 100
	 else
	 	size = atoi(arg[0])
		++arg ; --args
	which args
	0	s0 = s1 = 1
		v0 = 0 ; v1 = 1
	4	s0 = atof(arg[0]) ; s1 = atof(arg[1])
		v0 = atof(arg[2]) ; v1 = atof(arg[3])

	space(size, size)
	
	num r = min(w_2, h_2) - 10

	for(x, -w_2, w_2)
		for(y, -h_2, h_2)
			num a = Atan2(x, y)
			num i = hypot(x, y) / r
			
#			if !tween(a, -120, 120) && i<=1
			
			num s = i*(s1-s0) + s0
			num v = i*(v1-v0) + v0
			hsv(a, s, v)
		
			point(x, y)
		Paint()
 # todo, make it angle_unit ?


def for_exact(var, from, to, step)
	for(var, from+0.0, to+step/2.0, step+0.0)
!)@(#*$&%^ ./colour/rainbow
#!/lang/b

Main()
	paper(640, 480)
#	rb_green_power = 1

	dt = angle2rad(1)

	num r = 480/2*.9
	num a = 0

	spectrum()
#	cycle()


def cycle()
	repeat
		spectrum()
		num power
#		spin()
		pulse_spin(red)
		pulse_spin(green)
		pulse_spin(blue)

def X Sin(a)*r
def Y Cos(a)*r
  # these REALLY want to be local macros!

def spectrum()
	move(X, Y)
	for a = 0 ; a<360.5 ; ++a
		rainbow(a+0.5)
		move(0, 0)
		triangle(X, Y)
	Paint()
	Sleep(0.01)

def rainbow(a) _rainbow(angle2rad(a))
colour _rainbow(num a)
	num r = rb_power_1(a-rb_red_angle)
	num g = rb_power_1(a-rb_green_angle)
	num b = rb_power_1(a-rb_blue_angle)
#	num g = rb_green_power * (cos(a-rb_green_angle)+1)/2
#	num b = rb_blue_power * (cos(a-rb_blue_angle)+1)/2
#	r = pow(r, 1)
#	g = pow(g, 1)
#	b = pow(b, 1)
	return rgb(r, g, b)

num rb_power_1(num a)
	return (cos(a)+1)/2

num rb_power_2(num a)
	# constraints:
	#     0 -> 1
	# at 60 -> sqrt(2)
	# +-120 -> 0       and thereafter
	if a > pi
		a -= 2*pi
	num p = cos(a * 3.0/4.0)
	if p <= 0
		return 0
	return p

num rb_power_3(num a)
	# constraints:
	#     0 -> 1
	# at 60 -> 1
	# +-120 -> 0       and thereafter
	if a > pi
		a -= 2*pi

	if fabs(a) < deg2rad(60)
		return 1

	a = fsgn(a)*(fabs(a)-deg2rad(60))

	if fabs(a) >= deg2rad(60)
		return 0

	num p = cos(a * 180.0/60.0) / 2.0 + 0.5

	return p

num dt

def spin()
	rb_red_angle += 1.6*dt
	rb_green_angle += 2*dt
	rb_blue_angle += 1*dt

def pulse(which)
	for power=0; power < 360.1; power += 5
		rb_^^which^^_power = (Cos(power)+1)/2 * 0.8
		spectrum()

def pulse_spin(which)
	pulse(which)
		spin()

# move to m.b
num fsgn(num x)
	if x == 0.0
		return 0.0
	if x < 0.0
		return -1.0
	return 1.0

use main
use m
use gr
use error
use time
use io
!)@(#*$&%^ ./colour/rainbow3
#!/lang/b

Main()
	paper(640, 480)
#	rb_green_power = 1

	dt = angle2rad(1)

	num r = 480/2*.9
#	num a = 0

	spectrum()
#	cycle()


def cycle()
	repeat
		spectrum()
		num power
#		spin()
		pulse_spin(red)
		pulse_spin(green)
		pulse_spin(blue)

def X Sin(a)*r
def Y Cos(a)*r
  # these REALLY want to be local macros!

def spectrum()
	num a = -0.5
	move(X, Y)
	for a = 0 ; a<360.5 ;
		num rb_angle_fudge
		if a >= 0.0 && a < 120.0
			rb_angle_fudge = a
		if a >= 120.0 && a < 210.0
			rb_angle_fudge = (a-120.0) * 4.0/3.0 + 120.0
		if a >= 210.0
			rb_angle_fudge = (a-210.0) * 4.0/5.0 + 240.0
		rainbow(rb_angle_fudge)
		move(0, 0)
		a+=0.5
		triangle(X, Y)
		a+=0.5
	Paint()
	Sleep(0.01)

num dt

def spin()
	rb_red_angle += 1.6*dt
	rb_green_angle += 2*dt
	rb_blue_angle += 1*dt

def pulse(which)
	for power=0; power < 360.1; power += 5
		rb_^^which^^_power = (Cos(power)+1)/2 * 0.8
		spectrum()

def pulse_spin(which)
	pulse(which)
		spin()

use main
use m
use gr
use error
use time
use io
!)@(#*$&%^ ./colours
#!/lang/b
use b
Main()
	space()
	repeat
		each(x, red, green, blue, yellow, white, black, grey, purple, pink, brown, orange)
			clear(x) ; Paint()
			Readline()
!)@(#*$&%^ ./colour/spiral
#!/lang/b

Main()
	paper(640, 480, black)

	let(dt, angle2rad(1))
	dt = dt

	int R = 768/2

	int a[R*2+1][R*2+1]
	int d[R*2+1][R*2+1]
	colour rb[360]
	int np[R*2+1]

	for(i, 0, 360)
		rb[i] = rainbow(i)

	for(y, -R, R)
		let(X, (int)notpot(R, y))
		np[y+R] = X
		for(x, -X, X)
			d[x+R][y+R] = hypot(x, y)
			let(A, Atan2(y, x))
			a[x+R][y+R] = mod(((int)A), 360)

	let(da, 0.0)

	int first = 1
	wheel()
	Paint()
	Sleep(3)
	first = 0

	repeat
		wheel()
		Paint()
		#spin()
		#da -= 5
		da -= 8
		first = 0

def wheel()
	.
		for(i, 0, 360)
			rb[i] = rainbow(i)
		for(y, -R, R)
			let(X, np[y+R])
			for(x, -X, X)
				if rand() < 0.02 || first
					let(A, (a[x+R][y+R] + d[x+R][y+R]))
					if toss() || first
						A = mod(A*2+da/2, 360)
					else
						A = mod(A*3+da, 360)
					col(rb[A])
					point(x, y)

def spin()
	rb_red_angle += 1.6*dt
	rb_green_angle += 2*dt
	rb_blue_angle += -1*dt

use main
use m
use gr
use error
use time
use io
!)@(#*$&%^ ./colour/test
#!/lang/b
use b
use lib_extra.b

Main()
	space(600, 600)
	zoom(290)
	 # TODO default zoom is that a circle fits in space with a small margin??
	num A = 5
	num x0 = 0.3
	num y0 = 0
	num x1 = -Cos(A)/5  # are cos and sin misnamed (cos,integration primary?)
	num y1 = Sin(A)/2

	repeat
		clear()
		
		line(0, 0, x0, y0)
		line(0, 0, x1, y1)
		cyan()
		for(a, 0, A+1)  # TODO inclusive/exclusive for?  sane range objects?
			circular_blend(x, y, a/A, A)
			Sayf("%f %f", x*x0 + y*x1, x*y0 + y*y1)
			dot(x*x0 + y*x1, x*y0 + y*y1, 4*a_pixel)

		Paint()

		x0 += rand(-1, 1) * a_pixel
		y0 += rand(-1, 1) * a_pixel
		x1 += rand(-1, 1) * a_pixel
		y1 += rand(-1, 1) * a_pixel

def dot(x, y)
	point(x, y)

def trig_unit lun
!)@(#*$&%^ ./colour/tumble
#!/lang/b

use b
Main()
	v3  pos[]   = { {{-1, 0, 0}}, {{1, 0, 0}},   {{0, 0.2, 0}} }
	v3  vel[]   = { {{0, 0, .1}}, {{0, 0, -.1}}, {{0, 0, 0.1}} }
#	num mass[]  = { 1, 1, 0.5 }

	int n = 3

	space(400, 400)
	zoom(190)

	repeat
		plot()
		Paint()
		motion()

def plot()
	.
		int i
		for i=0 ; i<n ; ++i
			point(pos[i].x[0]+pos[i].x[2]*0.05, pos[i].x[1]+pos[i].x[2]*0.1)  # ignore Z for now

def motion()
	.
		# update position based on velocity
		int i
		for i=0 ; i<n ; ++i
			int j
			for j=0 ; j<3 ; ++j
				pos[i].x[j] += vel[i].x[j]
		# now, restore lengths, and modify velocity accordingly
		# .......
		# TODO look up rigid-body simulation on the internet

# TODO distinguish a number (unsigned) from a vector (signed) ?

struct v3
	num x[3]

struct arc
	int n[2]
!)@(#*$&%^ ./colour/wheel
#!/lang/b

Main()
	int size = atoi(Getenv("size", "400"))
	# NOTE for brace, always use env vars for real options
	# (as opposed to standard arguments)
	# have a "clear env" function, that clears all but standard env
	# vars.  also for brace?  was in BASIC   :D  yes with namespaces
	# Can clear to a certain previous LEVEL, e.g. base, or before a
	# block, etc.  and undo assignments / masking
	#   (e.g. drawing tree, GL context, modulation in music, etc)

	space(size, size)
	
	num r = h_2 - 10

	clear()
	num a = -5.5
	move(X, Y)
	
	#  red tang orang yello lime green aqua sky blue indigo purpl pink
	#  -5  -4   -3    -2    -1   0     1    2   3    4      5     6
	#  so  lo   la    ta    ti   do    ro   re  me   mi     fa    fo/sa
	#  (   {    [     <     /    o     \    >   ]    }      )     x    
	
	for a = -5 ; a < 6.5 ;
		rainbow(a)
		
		move(0, 0)
		a+=0.5
		triangle(X, Y)
		a+=0.5
	
	Paint()

def rainbow(a) rainbow_(a)  # rad2lun(angle2rad(a))
colour rainbow_(num a)
	# this angle must be measured in lunes!
	# or could do rad2lun(ang2rad(a)) but don't bother, yet
	#  I wonder if there is a nice trig-like series for sine(a*6/pi)  ?

	# there are three primaries red, green blue
	# and the three ranges between them.

	# for example every colour between red and green contains NO blue

	# the monitor of course should be tuned so white is white,
	# black is black and and grey is grey.
	# now to produce the rest of the colours :)

	# the range is from red, to pink-almost-red-again  :)

#	a = rmod(a, -5, 7)  # from [-5, 7)  # TODO 
	a = rmod(a, -5, 7)  # from [-5, 7)  # TODO 
	
	num a_r = rmod(a + 5, -6, 6)
	num a_g = rmod(a, -6, 6)
	num a_b = rmod(a - 4, -6, 6)

	return rgb((Cos(a_r)+1)/2, (Cos(a_g)+1)/2, (Cos(a_b)+1)/2)

#	if a == -5  # red
#		return rgb(1, 0, 0)
#	if a == 0  # green
#		return rgb(0, 1, 0)
#	if a == 4   # indigo
#		return rgb(0, 0, 1)

	if a > -5 && a < 0
		#  (red) tang orang yellow lime (green)
		solve_colour(r, g, a-(-5), 0-a)
		return rgb(r, g, 0)

	if a > 0 && a < 4
		#  (green) aqua sky blue (indigo)
		solve_colour(g, b, a, 4-a)
		return rgb(0, g, b)

	if a > 4 && a < 7
		#  (green) aqua sky blue (indigo)
		solve_colour(b, r, a-4, 7-a)
		return rgb(r, 0, b)

	bug("rainbow: a = %f !in [-5, 7) ?", a)
	Exit(1)  # keep gcc happy
	  # FIXME do bug, error, etc as macros that exit in the caller?

void bug(const char *format, ...)
	va_list ap
	va_start(ap, format)
	fprintf(stderr, "bug in ")
	vfprintf(stderr, format, ap)
	va_end(ap)
	fprintf(stderr, "\n")
	Exit(1)

def solve_colour(i0, i1, a0, a1)
	num my(a) = a0 + a1
	# to solve:  a0 * i0 == a1 * i1
	# and:       Cos(a0) * i0 + Cos(a1) * i1 == 1
	linear(i0, i1, 0, a0, -a1, 1, Cos(a0/my(a) * 3), Cos(a1/my(a) * 3))
	# the first equation is for colour balance (hue)
	#   e.g. orange: 1*i0 = 4*i1   ;   Cos(1)*i0 + Cos(4)*i1 = 1
	# the second for intensity (value)
	warn("solve_colour: a:%f a0:%f a1:%f -> i0:%f i1:%f", a, a0, a1, i0, i1)

def linear(x, y, a, b, c, d, e, f)
	# a  =  b*x + c*y
	# d  =  e*x + f*y
	num x, y
	if b != 0
	 	linear_(x, y, a, b, c, d, e, f)
	 else
		linear_(y, x, a, c, b, d, f, e)

# linear_ should be a func returning two values,
# make it nice to do that in brace..
def linear_(x, y, a, b, c, d, e, f)
	# assume b != 0  --  also if f*b - c*e == 0  we're in trouble :)
	# x  =  a-c*y / b   # b != 0   else  swap x y, etc
	# d  =  e*(a-c*y / b) + f*y
	# d - e*a/b  =  -e*c*y/b + f*y
	# d*b - e*a  =  (-e*c + f*b) * y
	num my(under) = f*b - c*e
	if my(under) == 0
		error("linear failed: parallel")
	y = (d*b - a*e) / my(under)
	x = a - (c*y / b)

def X Sin(a)*r
def Y Cos(a)*r

def whiten(x)
	x = 1 - (1-x)*(1-white)
def blacken(x)
	x = x*(1-black)
def whiten()
	whiten(red)
	whiten(green)
	whiten(blue)
def blacken()
	blacken(red)
	blacken(green)
	blacken(blue)

def trig_unit lun

use b
use lib_extra.b
!)@(#*$&%^ ./colour/wheel_guess
#!/lang/b

# try ./wheel.b 0.88 0.5 1

Main()
	num red_factor, green_factor, blue_factor
	which args
	0	red_factor = green_factor = blue_factor = 1
	3	red_factor = atof(arg[0])
		green_factor = atof(arg[1])
		blue_factor = atof(arg[2])
	else	usage("[red_factor green_factor blue_factor]")

	int size = atoi(Getenv("size", "400"))

	space(size, size)

	repeat
		clear()

		repeat
			FILE *f = freopen("./colours", "r", stdin)
			if f != NULL
				break

		num r = h_2 - 10
		num a = -7.5
		move(X, Y)
		read_tsv(red_, green_, blue_)  # , white_, black_)
			num red = atof(red_)
			num green = atof(green_)
			num blue = atof(blue_)
#			num white = atof(white_)
#			num black = atof(black_)
#			whiten() ; blacken()
			rgb(red*red_factor, green*green_factor, blue*blue_factor)
			move(0, 0)
			a += 15
			triangle(X, Y)

		Paint()
		
		Sleep(0.2)

def X Sin(a)*r
def Y Cos(a)*r

def whiten(x)
	x = 1 - (1-x)*(1-white)
def blacken(x)
	x = x*(1-black)
def whiten()
	whiten(red)
	whiten(green)
	whiten(blue)
def blacken()
	blacken(red)
	blacken(green)
	blacken(blue)

use b

export vec util

def read_tsv_vec(v)
	read_tsv_vec(v, my(l))
def read_tsv_vec(v, l)
	repeat
		cstr l = Input()
		if l == NULL
			break
		splitv(v, l)

def read_tsv_vec_n(v, n)
	read_tsv_vec_n(v, n, my(l))
def read_tsv_vec_n(v, n, l)
	read_tsv_vec(v, l)
		if vec_get_size(v) != n
			error("read_tsv_vec_n: expected %d columns, got %d", n, vec_get_size(v))

# this is a degenerate case! but they are usually important to have
def read_tsv()
	_read_tsv(my(v))
def _read_tsv(v)
	new(v, vec, cstr, 0)
	read_tsv_vec_n(v, 0)
		.
#FIXME Free(v)!

# this is sort of degenerate but not really!
def read_tsv(a1)
	_read_tsv(my(v), a1)
def _read_tsv(v, a1)
	new(v, vec, cstr, 1)
	read_tsv_vec_n(v, 1)
		cstr a1 = *(cstr *)vec_element(v, 0)
#FIXME Free(v)!

def read_tsv(a1, a2)
	_read_tsv(my(v), a1, a2)
def _read_tsv(v, a1, a2)
	new(v, vec, cstr, 2)
	read_tsv_vec_n(v, 2)
		cstr a1 = *(cstr *)vec_element(v, 0)
		cstr a2 = *(cstr *)vec_element(v, 1)
#FIXME Free(v)!

def read_tsv(a1, a2, a3)
	_read_tsv(my(v), a1, a2, a3)
def _read_tsv(v, a1, a2, a3)
	new(v, vec, cstr, 3)
	read_tsv_vec_n(v, 3)
		cstr a1 = *(cstr *)vec_element(v, 0)
		cstr a2 = *(cstr *)vec_element(v, 1)
		cstr a3 = *(cstr *)vec_element(v, 2)
#FIXME Free(v)!

def read_tsv(a1, a2, a3, a4)
	_read_tsv(my(v), a1, a2, a3, a4)
def _read_tsv(v, a1, a2, a3, a4)
	new(v, vec, cstr, 4)
	read_tsv_vec_n(v, 4)
		cstr a1 = *(cstr *)vec_element(v, 0)
		cstr a2 = *(cstr *)vec_element(v, 1)
		cstr a3 = *(cstr *)vec_element(v, 2)
		cstr a4 = *(cstr *)vec_element(v, 3)
#FIXME Free(v)!

def read_tsv(a1, a2, a3, a4, a5)
	_read_tsv(my(v), a1, a2, a3, a4, a5)
def _read_tsv(v, a1, a2, a3, a4, a5)
	new(v, vec, cstr, 5)
	read_tsv_vec_n(v, 5)
		cstr a1 = *(cstr *)vec_element(v, 0)
		cstr a2 = *(cstr *)vec_element(v, 1)
		cstr a3 = *(cstr *)vec_element(v, 2)
		cstr a4 = *(cstr *)vec_element(v, 3)
		cstr a5 = *(cstr *)vec_element(v, 4)
#FIXME Free(v)!

# etc!  need snazzy variadic macros :)

# FIXME is this split, fixed s->i, in the latest brace?  I think not

splitv(vec *v, cstr s, char c)
	vec_clear(v)
	vec_push(v, s)
	for_cstr(i, s)
		if *i == c
			*i = '\0'
			vec_push(v, i+1)

def splitv(v, s) splitv(v, s, '\t')

def for_cstr(i, s)
	char *i
	for i=s; *i != '\0'; ++i
		.
!)@(#*$&%^ ./colour/wheel_smooth
#!/lang/b

# try ./wheel.b 0.88 0.5 1

Main()
	num red_factor, green_factor, blue_factor
	if args % 3 == 1
		rb_smoothness = atof(arg[0])
		++arg ; --args
	which args
	0	red_factor = green_factor = blue_factor = 1
	3	red_factor = atof(arg[0])
		green_factor = atof(arg[1])
		blue_factor = atof(arg[2])
	else	usage("[red_factor green_factor blue_factor]")

	int size = atoi(Getenv("size", "400"))

	space(size, size)

	repeat
		clear()

		hsv_init()

		num r = h_2 - 10
		num da = 1
		num a = -da/2
		move(X, Y)

		for a=0 ; a<360-da/2 ;
			num i = a/30
			rainbow(i)
			move(0, 0)
			a += da/2
			triangle(X, Y)
			a += da/2

		Paint()
		
		Sleep(0.2)

#def rainbow(a) hsv(a, 0, 0)
#def hsv(a, w, b) hsv_(a, w, b)
#colour hsv_(num a, num white, num black)
#	# from [0, 12)
#	a *= 2
#	int i0 = a
#	int i1 = (i0+1) % 24
#	num blend = (a - i0)
#	blend = pow(fabs(blend-0.5) * 2, 1/smoothness)*fsgn(blend-0.5)/2 + 0.5
#	num red0 = rb_cols[i0].red
#	num green0 = rb_cols[i0].green
#	num blue0 = rb_cols[i0].blue
#	num red1 = rb_cols[i1].red
#	num green1 = rb_cols[i1].green
#	num blue1 = rb_cols[i1].blue
#	num red = (red1-red0)*blend+red0
#	num green = (green1-green0)*blend+green0
#	num blue = (blue1-blue0)*blend+blue0
#	whiten()
#	blacken()
#	return rgb(red, green, blue)

def X Sin(a)*r
def Y Cos(a)*r

use b
use lib_extra.b
!)@(#*$&%^ ./distribution
#!/lang/b
# this is a bar graph of Larry's "interesting distribution"
use b
Main()
	paper(800,600)
	origin(w_2,h_2)
	num logbase = log(1.05)
	int bars = w
	int counts[bars]
	for(i, 0, bars)
		counts[i] = 0
	int samples = 1e7
	int count = 0
	int ol = 0
	num lm = log(samples)/logbase
	repeat(samples)
		num x = Rand(Rand(Rand()))
		++counts[(int)(x * bars)]
		int l = log(++count)/logbase
		if l > ol
			grey(1-(num)l/lm)
			clear()
			draw_graph()
			Paint()
			ol = l
	int heading_size = 24
	font("helvetica-bold", 24)
	cstr msg
	if toss()
		msg = "Larry's \"interesting distribution\" - Rand(Rand(Rand()))"
	 else
		msg = "print rand rand rand 1, '\\n'; # interesting distribution"
	draw_msg(msg)
	Paint()
	Sleep(2)
	repeat
		move(randi(w), randi(h))
		hsv(randi(360), 1, 0.7)
		gprint_anchor(0, 0)
		font("helvetica-medium", randi(8, 48))
		gprintf("%f", Rand(Rand(Rand())))
		black()
		draw_graph()
		font("helvetica-bold", 24)
		gprint_anchor(-1, 1)
		draw_msg(msg)
		Paint()
		++heading_size

def draw_graph()
	int max = 0
	for(i, 0, bars)
		if counts[i] > max
			max = counts[i]
	for(i, 0, bars)
		line(i, 0, i, (num)counts[i]*h/max)

def draw_msg(msg)
	move(0, h)
	gprint(msg)
!)@(#*$&%^ ./flower
#!/lang/b

def usage()
	usage("[n1 n2 n3 n4]  e.g. 10 5 5 10")

Main()
	int n1, n2, n3, n4
	if args
		Getargs(int, n1, n2, n3, n4)
	 else
		eachp(x, n1, n2, n3, n4)
			*x = randi(1,13)

	Pr(int, n1, n2, n3, n4)

	space()

	for(o, 0.0, 360, 0.5)
		clear()
		for(i, 0, 360, 6)
			hsv(i, Cos(o*13)*0.15+0.85, Sin(o*7)*0.5+0.5)
			move(0,0)
			turn_to(o)
			right(i)
			move()
			forward(20)
			draw()
			forward(80)

			forward(100)

			let(da, Sin(o*n1+i*n2)*10)
			let(d, Cos(o*n3+i*n4)*10+12)
			repeat(20)
				left(da)
				forward(d)
				da = da*1.1
				d = d * 0.9
		Paint()
		Sleep(0.01)

use b
!)@(#*$&%^ ./flower-gif
#!/lang/b
use b

Main()
	paper(300, 300)
	zoom(3.0/6.0)
	line_width(8)

	int n1, n2, n3, n4

	which args
	4	n1 = atoi(arg[0])
		n2 = atoi(arg[1])
		n3 = atoi(arg[2])
		n4 = atoi(arg[3])
	0	n1 = 9 ; n2 = 12 ; n3 = 5 ; n4 = 12
	else	usage("[n1 n2 n3 n4]  e.g. 10 5 5 10")
		Exit(1)

	Sayf("%d %d %d %d", n1, n2, n3, n4)

	int count = 0

	for(oo, 0.0, 90, 0.75)
		num o = Sin(oo*4)*20
		clear()
		for(i, 0, 360, 6)
			hsv(i, 0.85, 0.3)
			move(0,0)
			turn_to(o*2)
			right(i)
			move()
			forward(20)
			draw()
			forward(80)

			forward(100)

			let(da, Sin(o*n1+i*n2)*10)
			let(d, Cos(o*n3+i*n4)*10+12)
			repeat(20)
				left(da)
				forward(d)
				da = da*1.1
				d = d * 0.9
		Paint()
		gr_sync()

		cstr file = format("flower-%06d.gif", count++)
		dump_img("gif", file, 0.25)
		Free(file)

		Sleep(0.01)

	System("gifsicle --colors 256 -O2 --delay 4 --loopcount flower-*.gif > flower.gif")
	System("rm flower-*.gif")
!)@(#*$&%^ ./fm
#!/lang/b
use b

num Fc, Fd, dt, t1

num message(num t)
	return sin(3 * 2*pi*t)

Main()
	paper(1024, 500)

	Fc = 20
	Fd = 10
	t1 = 1
	dt = t1 / w

	num integral_m = 0             # initial value
	for(t, 0.0, t1, dt)
		num m = message(t)
		integral_m += m * dt   # simplest numerical integration
		num y = cos(2*pi*(Fc*t + Fd*integral_m))
		curve(t * w/t1 - w_2, y * h_2 / 2)
	Paint()

!)@(#*$&%^ ./geon/geon.bb
# are all of these headers used here now?

use stdio.h

use main
use gr
use m
use error
use time

use al
use vector

use sphere
use poly
export regions
use debug
use clip_and_draw
use clip_and_fill
use palette
use draw_basic
use points
use clip_region_to_sector
use draw_clipped_arcs
use draw_sectors

# maybe should ALWAYS add using namespace std and using namespace __gnu_cxx to brace c++ ??

int window_width = 1024
int window_height = 768
num window_radius

int focus_region = -1

Main()
	num delta_latitude, delta_longitude, delta_spin, dfac_zoom
	num delay = 0
	int level, row, cell
	
	if argc != 14
		error("syntax: geon ns ew rot zoom dns dew drot fzoom delay focus_region level row cell")
	latitude = Rad(atof(argv[1]))
	longitude = Rad(atof(argv[2]))
	spin = Rad(atof(argv[3]))
	zm = atof(argv[4])
	delta_latitude = Rad(atof(argv[5]))
	delta_longitude = Rad(atof(argv[6]))
	delta_spin = Rad(atof(argv[7]))
	dfac_zoom = atof(argv[8])
	delay = atof(argv[9])
	focus_region = atoi(argv[10])
	level = atoi(argv[11])
	row = atoi(argv[12])
	cell = atoi(argv[13])
	
	load_and_convert_regions("data/regions")
	load_points("data/points")
	
#	paper(window_width, window_height)
	paper()
	window_radius = hypot(window_width/2, window_height/2)
	load_palette("data/palette")
	zoom(r*zm)
	
	bool display_focus = focus_region >= 0 && (unsigned int)focus_region < regions.size()
	if display_focus
		latitude = regions[focus_region].points_a[0].latitude
		longitude = regions[focus_region].points_a[0].longitude
		#debug("%f\n", deg(ns))
		#debug("%f\n", deg(ew))
	
	sector_id focus_sector_id = { level, row, cell }
	sector_bounds focus_sector_bounds
	bool display_focus_sector = level >= 0 && cell >= 0
	# row can be < 0
	
	region_sector_containment containment
	vector<clip_to_sector_arc> clipped_arcs
	
	if display_focus_sector
		calc_sector_bounds(focus_sector_id, focus_sector_bounds)
		clip_region_to_sector(regions[0].points_a, focus_sector_bounds, containment, clipped_arcs)
		latitude = (focus_sector_bounds.south + focus_sector_bounds.north) / 2
		longitude = (focus_sector_bounds.west + focus_sector_bounds.east) / 2
	
	repeat
		#debug("%f %f %f", deg(ns), deg(ew), deg(rot))
		
		num pixel = 1/(r*zm)
		if r*zm < window_radius + 10*pixel
			bg(col_space)
			clear()
			col(col_sea)
			disc(0, 0, 1-pixel)
		else
			bg(col_sea)
			clear()
		for_each(regions, fill_region)
		if display_focus
			col(col_focus)
#			poly_vec3_vp_clip_and_draw(regions[focus_region].points_v)
		if level >= 0
			col(col_grid)
			draw_sector_grid(level)
		col(col_point)
		draw_points(points_v)
		# draw the equator
		#draw_parallel(0)
		if display_focus_sector
			# draw the focus sector
			draw_sector_bounds(focus_sector_bounds)
			draw_clipped_arcs(regions[focus_region].points_v, clipped_arcs)
		# this was supposed to trim the mess at the edge of the circle,
		# and make it unnecessary to use `clear()' - but I prefer the other way
		# maybe I'll try to do it properly one day!
		#colc(col_space)
		##rgb(1, 1, 1)
		#circle(0, 0, 1)
		#circle(0, -pixel, 1)
		#circle(0, pixel, 1)
		#circle(-pixel, 0, 1)
		#circle(pixel, 0, 1)
		
		Paint()
		
		if delay < 0
			break
		Rsleep(delay)
		
		latitude += delta_latitude
		longitude += delta_longitude
		spin += delta_spin
		
		zm *= dfac_zoom
		zoom(r*zm)
	
	event_loop()
	return 0

fill_region(region &r)
	if r.type == LAND
		col(col_land)
	eif r.type == LAKE
		col(col_lake)
	else
		error("unknown region type %d", (int)r.type)
	poly_vec3_vp_clip_and_fill(r.points_v)
!)@(#*$&%^ ./heart
#!/lang/b

use b

num hue_edge
num hue_middle

Main()
	hue_middle = 295 # yellow->red
	hue_edge = 110   # pink->light blue
	if args == 2
		hue_middle = atof(arg[0])
		hue_edge = atof(arg[1])

	paper(blue)
	rb_green_power = 1

	heart(0, 0, 150)

heart(num x, num y, num r)
	origin(x, y)

	struct polygon p_
	struct polygon *p = &p_

	num squash_y = 0.7


	num r0
	num r_growing
	num r0_step = 3
	for r_growing = 0; r_growing <= r ; r_growing++
		for r0=r_growing ; r0>0 ; r0-=r0_step
			rainbow(stretch1(r0, 0, r, hue_middle, hue_edge))

			num x_scale = stretch(r0, r, 0, 1, 1.4)

			num rt3on2 = sqrt(3)/2
			num top_semi_r = r0 / (1 + sqrt(2)/2)
			num top_semi_offset = top_semi_r - r0/2

			num y_up = r0/2
			num y_down = rt3on2*squash_y * r0*2
			num yoff = (y_down - y_up)/2

			polygon_start(p, 100)

			num a
			
			for a=150; a>=90; --a
				polygon_point(p, x_scale*(-r0 + Sin(a)*r0*2), Cos(a)*r0*2*squash_y + yoff)
			for a=90; a>=-45; --a
				polygon_point(p, x_scale*(r0/2 - top_semi_offset + Sin(a)*top_semi_r), Cos(a)*top_semi_r + yoff)
			for a=45; a>=-90; --a
				polygon_point(p, x_scale*(-r0/2 + top_semi_offset + Sin(a)*top_semi_r), Cos(a)*top_semi_r + yoff)
			for a=-90; a>=-150; --a
				polygon_point(p, x_scale*(r0 + Sin(a)*r0*2), Cos(a)*r0*2*squash_y + yoff)

			polygon_fill(p)
			polygon_end(p)
		Paint()

def stretch(x, in0, in1, out0, out1) (x-in0)/(in1-in0)*(out1-out0)+out0
def stretch1(x, in0, in1, out0, out1) pow((x-in0)/(in1-in0), 3)*(out1-out0)+out0
!)@(#*$&%^ ./kosmogram/kosmogram
#!/lang/b

# TODO make the blending look good when viewed from an angle
# TODO fix the planet positions to be real at some base time!

def system_in 40
def system_out 185
def stars_start 190
def balance 1.25
def n_planets 9
def earth_dist 70

def secs_in_day 3600 * 24

def array_last(a) array_end(a)-1

colour rb[360]

rb_init()
	for(i, 0, 360)
		rb[i] = rainbow(i)

def rb(a) col(rb[mod((int)(a+0.5), 360)])

# 1956.10.28 9.0.0  -  +42.30.17 +10.7.3

struct place
	num ns, ns_min, ns_sec
	num ew, ew_min, ew_sec

place_init(place *p, num ns, num ns_min, num ns_sec, num ew, num ew_min, num ew_sec)
	p->ns = ns
	p->ns_min = ns_min
	p->ns_sec = ns_sec
	p->ew = ew
	p->ew_min = ew_min
	p->ew_sec = ew_sec

struct time_place
	datetime time
	place place

num planet_a[n_planets]
num planet_r[] = { 3, 4, 5, 4, 8, 7, 6, 6, 3 }

num earth_orbit = 365.26 * secs_in_day
num planet_period[] = { 0.241, 0.615, 1.0, 1.88, 11.86, 29.46, 84, 164.8, 247.7 }
num planet_dist[] = { 0.387, 0.723, 1.0, 1.524, 5.203, 9.539, 19.18, 30.06, 39.53 }

num yscale

boolean anim = 1

num basea

Main()
	decl(birth, time_place)
	ref(birth_t, birth->time)
	ref(birth_p, birth->place)

	cstr person_name = toss() ? "Joe Bloggs" : "Jane Doe"

	switch args
	1	person_name = arg[0]
	0	datetime_init(birth_t, randi(1970, 2006), randi(1, 13), randi(1, 28),  randi(24), randi(60), randi(60))
		place_init(birth_p, randi(-90, 90), randi(60), randi(60),  randi(-180, 180), randi(60), randi(60))
		break
		#datetime_init(birth_t, 1976,9,1, 0,0,0)
		#place_init(birth_p, +42,30,17, 10,7,3)
		# datetime_init(&b.t, 1956,10,28, 9,0,0)
		# TODO localtime?? gmtime?? timezone??
	13	person_name = arg[0]
		++arg
	12	datetime_init(birth_t, atoi(arg[0]), atoi(arg[1]), atoi(arg[2]), atoi(arg[3]), atoi(arg[4]), atoi(arg[5]))
		place_init(birth_p, atoi(arg[6]), atoi(arg[7]), atoi(arg[8]), atoi(arg[9]), atoi(arg[10]), atoi(arg[11]))
		break
	else	usage("[name] year month day  hour min sec    ns min sec  ew min sec")

	#paper(1280, 800, spaceblue)
#	paper(640, 800, spaceblue = rgb(0, 0, 0.05))
	paper(spaceblue = rgb(0, 0, 0.05))
#	paper(640, 480, spaceblue = rgb(0, 0, 0.05))
	#paper(1280, 800, rgb(0, 0, 0))
	rb_init()
	grey_init()
	key_init()

	font("-adobe-helvetica-medium-r-normal--11-80-100-100-p-56-iso8859-1")
#	font("-adobe-helvetica-medium-r-normal--34-*-100-100-p-*-iso8859-1")

	num t = Mktime(birth_t)
	 # FIXME rewrite Mktime to handle older dates than 1970

	num ns = birth_p->ns + birth_p->ns_min/60.0 + birth_p->ns_sec/3600.0
	num ew = birth_p->ew + birth_p->ew_min/60.0 + birth_p->ew_sec/3600.0
	ew = ew

	yscale = Cos(ns)
#	yscale = 0.5

#	Sayf("%f %f %f", t, ns, ew)

#	coln("darkgrey")
#	Disc(22, 22, 6)

	int n_stars=500
	int star_x[n_stars], star_y[n_stars]
	colour star_c[n_stars]

	for(c, 0, n_stars)
		star(c)

	seed(0)
	let(last_dist, planet_dist[n_planets-1])
	eachplanet(i)
		planet_period[i] *= earth_orbit
#		planet_dist[i] *= system_out / last_dist
		planet_dist[i] = log(planet_dist[i])/log(last_dist) * (system_out-earth_dist) + earth_dist
		planet_a[i] = Rand(360)
#		Sayf("%f %f", planet_period[i], planet_dist[i])
		 # set up initial (1970) posn of planets - FIXME random for now!
	seed()

#	real dt = 10

#	real bend = 20.0

#	real z = 1
	zoom(1)

	repeat
#		let(phase, 0)
		for(phase, 0, 360)
# the following moves so that the sun would be up at noon, etc (assumes time given is localtime, ignores ns/ew)
			if !anim
				basea = 0
				planet_pos(earth, earth_r, _basea, earth_x, earth_y)
				u(earth_x) ; u(earth_y)
				basea = -_basea
	#			basea += 360 / 24 * birth_t->tm_hour
				basea += 360 / 24 * t / 3600 #birth_t->tm_hour
	#			planet_pos(earth, earth_r_1, earth_a_1, earth_x_1, earth_y_1)
	#			origin(earth_x_1, earth_y_1*yscale)

#			z=-Cos(t)*0.2 + 1.2
#			zoom(z)

			clear()

#			back(r, system_out*2+10.0, 200)
#				rgb(0, 0, 0.05*r/(system_out*2+10))
#				Disc(0, 0, r)
			stars()

#			real da = Sin(phase) * bend

			grey()
			move_to_text_origin()
			gsay(person_name)
			gsay_date(t)
			gsay_place(birth_p)

#			midnightblue()
			starburst()
			if anim
				blended_curves()
			else
				curve_orig()
			thin()

			sun()

			.
				eachplanet(i)
					if i != earth
						planet()

			int i = earth
			planet()

			Paint()
			Sleep(0.01)
			#Sleep(1)
			if !anim
				switch key()
				27	.
				'q'	done
				anim = 1

			t += dt
done	.

def every(n)
	static int my(c) = 0
	if my(c)++ == n
		my(c) = 0
	which my(c)

def sqrrand(from, to) sqr(Rand()) * (to-from) + from

def sun()
	if anim
		every(2)
		0	yellow()
		2	white()
	else
		grey()
	for(a, 0, 360, 10)
		polar_to_rec_clock(0, 0, a+Rand(-0.5, 0.5), sqrrand(20, 35), x, y)
		let(d, hypot(x, y))
		num f = (19+Rand(-0.5, 0.5))/d
		line(x*f, y*f, x, y)
	if anim
		every(4)
		0	white()
		1	cyan()
		2	orange()
		3	yellow()
	else
		yellow()
	Disc(0, 0, 15)

def stars()
	for(c, 0, n_stars)
		if toss()
			col(star_c[c])
		else
			white()
		point(star_x[c], star_y[c])
	int c = Rand(n_stars)
	star(c)

def star(c)
	repeat
		let(b, Rand(1))
		num tint = 0.55
		star_c[c] = rgb(b+Rand(tint), b+Rand(tint), b+Rand(tint))
		star_x[c] = Rand(-w/2, w/2)
		star_y[c] = Rand(-h/2, h/2)
		if hypot(star_x[c], star_y[c]/yscale) > stars_start
			break

def planet_pos(i, r, a, x, y)
#	let(r, system_in + pow(i, balance)/pow(8, balance)*(system_out-system_in))
	let(r, planet_dist[i])
	let(a, planet_a[i] + 360 * t * 1.0/planet_period[i])
	a += basea
	polar_to_rec_clock(0, 0, a, r, x, y)

def polar_to_rec_clock(x0, y0, a, r, x1, y1)
	polar_to_rec(y0, x0, a, r, y1, x1)

def star_pos(i, x, y)
	let(x, star_x[i])
	let(y, star_y[i])

def planet()
	.
		planet_pos(i, r, a, x, y)
		rainbow(-60 + i*330/8)
		#width(2)
#		Circle(0, 0, r)
		num pr = planet_r[i]

		if i == earth
			Disc(x, y, pr)
			grey()
			moon()
		eif i == pluto_charon
			pluto_charon()
		else
			Disc(x, y, pr)

		if i == saturn
			grey()
			every(4)
			0	Circle(x, y, pr + 4)
				Circle(x, y, pr + 6)
			else	Circle(x, y, pr + 5)
				Circle(x, y, pr + 7)

int earth = 2
int saturn = 5
int pluto_charon = 8

# XXX fixme 28?
def moon()
	polar_to_rec_clock(x, y, 360*t/secs_in_day/28, 12, mx, my)
	Disc(mx, my, 2)

def pluto_charon()
	int oa = -a*1000
	int pc_r = 3
	polar_to_rec_clock(x, y, oa, pc_r, pluto_x, pluto_y)
	Disc(pluto_x, pluto_y, 1)
	polar_to_rec_clock(x, y, oa+180, pc_r, charon_x, charon_y)
	Disc(charon_x, charon_y, 1)

def eachplanet(i)
	for(i, 0, n_planets)
def eachstar(i)
	for(i, 0, n_stars)

def PrintDate(dt)
	SayFree(Timef(dt, dt_format))

# people have some CHOICE, they can choose either one arc or the other at each planet transition

def blended_curves()
	.
		# connect the planets with a curve...
		#width(2)
		planet_pos(0, or, oa, x0, y0)
		
		eachplanet(i)
			if i == 0
				continue
			planet_pos(i, r, a, x1, y1)
			blended_curve(i, x0, y0, or, oa, r, a)
			x0 = x1 ; y0 = y1
			or = r ; oa = a

blended_curve(int i, num x0, num y0, num or, num oa, num r, num a)
	num da = a - oa
	da = rmod(da, 360)
	num da1 = -(360-da)
#	if (da > 180) ^ golong
	if da > 180
		swap(da, da1)

	num wp = or*or / 100 #100 * or/300
	num aweight = 1-pow(fabs(da)/360, wp)*pow(2, wp-1)
	num a1weight = 1-aweight

	num maxda = nmax(fabs(da), fabs(da1))
	int steps = 1 + (int)maxda / 3

	da /= steps
	da1 /= steps

	num dr = (r - or) / steps
	num p = 0.0
	num dp = 1.0/steps
	num oa1 = oa

	Move(x0, y0)
	for ; steps > 0; --steps
#			if steps % 2
		rb(-60 + (i+p)*330/8)
#			else
#				black()
		oa += da
		oa1 += da1
		or += dr
		polar_to_rec_clock(0, 0, oa, or, x, y)
		polar_to_rec_clock(0, 0, oa1, or, x_, y_)
#		Draw(x, y)
#		Draw(x_, y_)
		u(x) ; u(y)
		u(x_) ; u(y_) ; u(aweight) ; u(a1weight)
		#Draw(x*aweight + x_*a1weight, y*aweight + y_*a1weight)
		let(w, or/240 * wavg(planet_r[i-1], planet_r[i], p))
		w = bound(w, 1, 3)
		wide_line(lx, ly/yscale, x*aweight + x_*a1weight, y*aweight + y_*a1weight, w)
		p+=dp

wide_line(num x0, num y0, num x1, num y1, num w)
	width(w)
	unit(x1-x0, y1-y0, ux, uy)
	ux *= w/2 ; uy *= w/2
	Line(x0-ux, y0-uy, x1+ux, y1+uy)
	Move2(x0, y0, x1, y1)
	thin()

def unit(dx, dy, ux, uy)
	let(d, hypot(dx, dy))
	let(ux, dx / d)
	let(uy, dy / d)

def wavg(a, b, w) a*(1-w) + b*w

def u(v) v=v

def curves()
	.
		# connect the planets with a curve...
		width(2)
		planet_pos(0, or, oa, x0, y0)
		
		eachplanet(i)
			if i == 0
				continue
			planet_pos(i, r, a, x1, y1)
			draw_curve(i, x0, y0, or, oa, r, a, 0)
			draw_curve(i, x0, y0, or, oa, r, a, 1)
			x0 = x1 ; y0 = y1
			or = r ; oa = a

#x=x ; y=y  # keep gcc happy  IDEA for macros; omit to do an op if the result isn't ever used;
	   #                 this would keep gcc happy too!

draw_curve(int i, num x0, num y0, num or, num oa, num r, num a, boolean golong)
	num da = a - oa
	da = rmod(da, 360)
	num da1 = -(360-da)
	if (da > 180) ^ golong
		swap(da, da1)

	Move(x0, y0)
	int steps = 1 + (int)fabs(da) / 5 #(150/r) # equal size steps
	da /= steps
	num dr = (r - or) / steps
	num p = 0.0
	num dp = 1.0/steps
	for ; steps > 0; --steps
#			if steps % 2
		rb(-60 + (i+p)*330/8)
#			else
#				black()
		oa += da
		or += dr
		polar_to_rec_clock(0, 0, oa, or, x, y)
		Draw(x, y)
		p+=dp

# need to be able to define macros from within a macro

def curve_orig()
	.
		# connect the planets with a curve...
		width(2)
		planet_pos(0, or, oa, x, y)
		Move(x, y)
		eachplanet(i)
			if i == 0
				continue
			planet_pos(i, r, a, x, y)
			x=x ; y=y  # keep gcc happy
			num da = a - oa
			da = rmod(da, 360)
			if da > 180
				da = -(360-da)
			int steps = 1 + (int)fabs(da) / 5 #(150/r) # equal size steps
			da /= steps
			num dr = (r - or) / steps
			num p = 0.0
			num dp = 1.0/steps
			for ; steps > 0; --steps
#				if steps % 2
				rb(-60 + (i+p)*330/8)
#				else
#					black()
				oa += da
				or += dr
				polar_to_rec_clock(0, 0, oa, or, x, y)
				Draw(x, y)
				p+=dp
			
			or = r ; oa = a

def Toss()
	if toss()

# TODO sun is planet[0] !

def starburst()
	.
		# connect the planets with a curve...
		width(2)
		eachplanet(j)
			if j != earth
				connect(0, earth, j)
		connectsun(1, earth)
		#planet_pos(earth, r0, a0, x0, y0)
		#connect_grey(1, x0, y0, 0, 0)
		#connect_grey(1, 0, 0, x0, y0)
#			eachplanet(i)
#				if i > j #&& i != earth && j != earth
#		eachplanet(i)
#			connect(earth, i)

#		eachstar(s)
#			connectstar(s)

def connect(strong, A, B)
	planet_pos(A, r0, a0, x0, y0)
	planet_pos(B, r1, a1, x1, y1)
	connect_grey(strong, x0, y0, x1, y1)

def connectsun(strong, A)
	planet_pos(A, r0, a0, x0, y0)
	let(x1, 0.0) ; let(y1, 0.0)
	connect_grey(strong, x0, y0, x1, y1)

def connectstar(S)
	star_pos(S, x1, y1)
	connect_grey(0, 0, 0, x1, y1)

# IDEA - once have auto decl, won't need to worry about whether decl'd or not

def greypowhigh 6
def greypowlow 2
def burst_len 100
def connect_grey(strong, x0, y0, x1, y1)
	Move(x0, y0)
	let(my(d), dist(x0, y0, x1, y1))
	let(my(bl), 1/sqr(my(d)) * 1000000)
	my(bl) = bound(my(bl), 0, my(d))
	x1 = x0 + (x1-x0) * my(bl)/my(d)
	y1 = y0 + (y1-y0) * my(bl)/my(d)
	my(d) = my(bl)
#	let(my(d), dist(x0, x0, x1, y1))
	for(my(p), 0.0, 1, 1/my(d))
		let(xx, x0 + (x1-x0)*my(p))
		let(yy, y0 + (y1-y0)*my(p))
#		if toss()
#			black()
#		else
#			white()
#		rb(-60 + (i*R/r)*330/8.0)
		num v
		if !anim || toss()
			#rb(-60 + p*i*330/8.0)
			if strong
				v = pow(1-my(p), greypowlow)
			else
				v = pow(1-my(p), greypowhigh)
		else
			v = 0
#		if v > 0.01 && p*d > 10 && (1-p)*d > 10
	#	if v > 0.01 #p*d > 10 && (1-p)*d > 10 #&& v > 0.01
		gr(v)
		Draw(xx, yy)
#		else
#			Move(xx, yy)

def bound(a, low, high) a < low ? low : a > high ? high : a


colour gr[256]

grey_init()
	for(i, 0, 256)
		gr[i] = grey(i/256.0)

def gr(p) col(gr[bound((int)(p*256), 0, 256)])
def grey(p) rgb(p, p, p*.95+.05)

num dt = secs_in_day / 2 #/ 4 #* 2 #/ 24
#real dt = secs_in_day / 24 / 4 # 15 min 962 #/ 4 #* 2 #/ 24

# TODO put in "colours" file
colour spaceblue

def gsay_date(t)
	# print the date
	decl(currenttime, datetime)
	Localtime(t, currenttime)
	cstr birth_t_cstr = Timef(currenttime, dt_format)
	gsay(birth_t_cstr)
	Free(birth_t_cstr)

def gsay_place(p)
	# print the place
	cstr NS
	cstr EW
	int ns = p->ns
	int ew = mod(p->ew, 360)
	if ew > 180
		ew -= 360

	# FIXME have N/S E/W in place (a separate sign)
	# otherwise ~ equator there are problems
	if ns >= 0
		NS = "N"
	else
		NS = "S"
		ns = -ns
	if ew >= 0
		EW = "E"
	else
		EW = "W"
		ew = -ew

	# todo mod to a - to + range...
	gsayf("%d:%d'%d\"%s  %d:%d'%d\"%s", ns, p->ns_min, p->ns_sec, NS, ew, p->ew_min, p->ew_sec, EW)

def Move(x, y)
	move(x, y*yscale)

def Draw(x, y)
	draw(x, y*yscale)

def Point(x, y)
	point(x, y*yscale)

def Circle(x, y, r)
	circle(x, y*yscale, r)

def Disc(x, y, r)
	disc(x, y*yscale, r)

def Move2(x0, y0, x1, y1)
	move2(x0, y0*yscale, x1, y1*yscale)

def Line(x0, y0, x1, y1)
	line(x0, y0*yscale, x1, y1*yscale)

use gr
use util
use m
use main
use time
use error
use alloc
use key
!)@(#*$&%^ ./kosmogram/kosmogram.b.old
#!/lang/b

def system_in 40
def system_out 185
def balance 1.25
def n_planets 9
def earth_dist 70

def secs_in_day 3600 * 24

def array_last(a) array_end(a)-1

colour rb[360]

rb_init()
	for(i, 0, 360)
		rb[i] = rainbow(i)

def rb(a) col(rb[mod((int)(a+0.5), 360)])

# 1956.10.28 9.0.0  -  +42.30.17 +10.7.3

struct time_place
	datetime time
	place place

real planet_a[n_planets]
real planet_r[] = { 3, 4, 5, 4, 8, 7, 6, 6, 3 }

real earth_orbit = 365.26 * secs_in_day
real planet_period[] = { 0.241, 0.615, 1.0, 1.88, 11.86, 29.46, 84, 164.8, 247.7 }
real planet_dist[] = { 0.387, 0.723, 1.0, 1.524, 5.203, 9.539, 19.18, 30.06, 39.53 }

boolean anim = 0

real basea

Main()
	decl(birth, time_place)
	ref(birth_t, birth->time)
	ref(birth_p, birth->place)

	cstr person_name = toss() ? "Joe Bloggs" : "Jane Doe"

	switch args
	1	person_name = arg[0]
	0	datetime_init(birth_t, randi(1970, 2006), randi(1, 13), randi(1, 28),  randi(24), randi(60), randi(60))
		place_init(birth_p, randi(-90, -90), randi(60), randi(60),  randi(-180, 180), randi(60), randi(60))
		break
		#datetime_init(birth_t, 1976,9,1, 0,0,0)
		#place_init(birth_p, +42,30,17, 10,7,3)
		# datetime_init(&b.t, 1956,10,28, 9,0,0)
		# TODO localtime?? gmtime?? timezone??
	13	person_name = arg[0]
		++arg
	12	datetime_init(birth_t, atoi(arg[0]), atoi(arg[1]), atoi(arg[2]), atoi(arg[3]), atoi(arg[4]), atoi(arg[5]))
		place_init(birth_p, atoi(arg[6]), atoi(arg[7]), atoi(arg[8]), atoi(arg[9]), atoi(arg[10]), atoi(arg[11]))
		break
	else	usage("[name] year month day  hour min sec    ns min sec  ew min sec")

	#paper(1280, 800, spaceblue)
#	paper(640, 800, spaceblue = rgb(0, 0, 0.05))
	paper(640, 480, spaceblue = rgb(0, 0, 0.05))
	#paper(1280, 800, rgb(0, 0, 0))
	rb_init()
	grey_init()
	key_init()

#	font("-adobe-helvetica-medium-r-normal--11-80-100-100-p-56-iso8859-1")
	font("-adobe-helvetica-medium-r-normal--34-*-100-100-p-*-iso8859-1")

	real t = Mktime(birth_t)
	 # FIXME rewrite Mktime to handle older dates than 1970

	real ns = birth_p->ns + birth_p->ns_min/60.0 + birth_p->ns_sec/3600.0
	real ew = birth_p->ew + birth_p->ew_min/60.0 + birth_p->ew_sec/3600.0

	Sayf("%f %f %f", t, ns, ew)

#	coln("darkgrey")
#	disc(22, 22, 6)

	int n_stars=500
	int star_x[n_stars], star_y[n_stars]
	colour star_c[n_stars]

	for(c, 0, n_stars)
		star(c)

	seed(0)
	let(last_dist, planet_dist[n_planets-1])
	eachplanet(i)
		planet_period[i] *= earth_orbit
#		planet_dist[i] *= system_out / last_dist
		planet_dist[i] = log(planet_dist[i])/log(last_dist) * (system_out-earth_dist) + earth_dist
		planet_a[i] = Rand(360)
#		Sayf("%f %f", planet_period[i], planet_dist[i])
		 # set up initial (1970) posn of planets - FIXME random for now!
	seed()

#	real dt = 10

#	real bend = 20.0

#	real z = 1
	zoom(1)

	real yscale = sin(ns)
	yscale = yscale

	repeat
#		let(phase, 0)
		for(phase, 0, 360)
			basea = 0
			planet_pos(earth, earth_r, _basea, earth_x, earth_y)
			u(earth_x) ; u(earth_y)
# the following moves so that the sun would be up at noon, etc (assumes time given is localtime, ignores ns/ew)
# disabled as it makes the animation ugly
#			basea = -_basea
#			basea += 360 / 24 * birth_t->tm_hour

			basea = 0
			
#			z=-Cos(t)*0.2 + 1.2
#			zoom(z)

			clear()

#			back(r, system_out*2+10.0, 200)
#				rgb(0, 0, 0.05*r/(system_out*2+10))
#				disc(0, 0, r)
			stars()

#			real da = Sin(phase) * bend

			grey()
			move_to_text_origin()
			gsay(person_name)
			gsay_date(t)
			gsay_place(birth_p)

#			midnightblue()
			starburst()
			if anim
				blended_curves()
			else
				curve_orig()
			thin()

			sun()

			.
				eachplanet(i)
					if i != earth
						planet()

			i = earth
			planet()

			Paint()
			Sleep(0.01)
			#Sleep(1)
			if !anim
				switch key()
				27	.
				'q'	done
				anim = 1

			t += dt
done	.

def every(n)
	static int my(c) = 0
	if my(c)++ == n
		my(c) = 0
	which my(c)

def sqrrand(from, to) sqr(Rand()) * (to-from) + from

def sun()
	if anim
		every(2)
		0	yellow()
		2	white()
	else
		grey()
	for(a, 0, 360, 10)
		polar_to_rec_clock(0, 0, a+Rand(-0.5, 0.5), sqrrand(20, 35), x, y)
		let(d, hypot(x, y))
		real f = (19+Rand(-0.5, 0.5))/d
		line(x*f, y*f, x, y)
	if anim
		every(4)
		0	white()
		1	cyan()
		2	orange()
		3	yellow()
	else
		yellow()
	disc(0, 0, 15)

def stars()
	for(c, 0, n_stars)
		if toss()
			col(star_c[c])
		else
			white()
		point(star_x[c], star_y[c])
	c = Rand(n_stars)
	star(c)

def star(c)
	repeat
		let(b, Rand(1))
		real tint = 0.55
		star_c[c] = rgb(b+Rand(tint), b+Rand(tint), b+Rand(tint))
		star_x[c] = Rand(-w/2, w/2)
		star_y[c] = Rand(-h/2, h/2)
		if hypot(star_x[c], star_y[c]) > system_out
			break

def planet_pos(i, r, a, x, y)
#	let(r, system_in + pow(i, balance)/pow(8, balance)*(system_out-system_in))
	let(r, planet_dist[i])
	let(a, planet_a[i] + 360 * t * 1.0/planet_period[i])
	a += basea
	polar_to_rec_clock(0, 0, a, r, x, y)

def polar_to_rec_clock(x0, y0, a, r, x1, y1)
	polar_to_rec(y0, x0, a, r, y1, x1)

def star_pos(i, x, y)
	let(x, star_x[i])
	let(y, star_y[i])

def planet()
	.
		planet_pos(i, r, a, x, y)
		rainbow(-60 + i*330/8)
		#width(2)
#		circle(0, 0, r)
		real pr = planet_r[i]

		if i == earth
			disc(x, y, pr)
			grey()
			moon()
		eif i == pluto_charon
			pluto_charon()
		else
			disc(x, y, pr)

		if i == saturn
			grey()
			every(4)
			0	circle(x, y, pr + 4)
				circle(x, y, pr + 6)
			else	circle(x, y, pr + 5)
				circle(x, y, pr + 7)

int earth = 2
int saturn = 5
int pluto_charon = 8

# XXX fixme 28?
def moon()
	polar_to_rec_clock(x, y, 360*t/secs_in_day/28, 12, mx, my)
	disc(mx, my, 2)

def pluto_charon()
	int oa = -a*1000
	int pc_r = 3
	polar_to_rec_clock(x, y, oa, pc_r, pluto_x, pluto_y)
	disc(pluto_x, pluto_y, 1)
	polar_to_rec_clock(x, y, oa+180, pc_r, charon_x, charon_y)
	disc(charon_x, charon_y, 1)

def trig_unit deg

def eachplanet(i)
	for(i, 0, n_planets)
def eachstar(i)
	for(i, 0, n_stars)

def PrintDate(dt)
	SayFree(Timef(dt, dt_format))

# people have some CHOICE, they can choose either one arc or the other at each planet transition

def blended_curves()
	.
		# connect the planets with a curve...
		#width(2)
		planet_pos(0, or, oa, x0, y0)
		
		eachplanet(i)
			if i == 0
				continue
			planet_pos(i, r, a, x1, y1)
			blended_curve(i, x0, y0, or, oa, r, a)
			x0 = x1 ; y0 = y1
			or = r ; oa = a

blended_curve(int i, real x0, real y0, real or, real oa, real r, real a)
	real da = a - oa
	da = rmod(da, 360)
	real da1 = -(360-da)
#	if (da > 180) ^ golong
	if da > 180
		swap(da, da1)

	real wp = or*or / 100 #100 * or/300
	real aweight = 1-pow(fabs(da)/360, wp)*pow(2, wp-1)
	real a1weight = 1-aweight

	real maxda = nmax(fabs(da), fabs(da1))
	int steps = 1 + (int)maxda / 3

	da /= steps
	da1 /= steps

	real dr = (r - or) / steps
	real p = 0.0
	real dp = 1.0/steps
	real oa1 = oa

	move(x0, y0)
	for ; steps > 0; --steps
#			if steps % 2
		rb(-60 + (i+p)*330/8)
#			else
#				black()
		oa += da
		oa1 += da1
		or += dr
		polar_to_rec_clock(0, 0, oa, or, x, y)
		polar_to_rec_clock(0, 0, oa1, or, x_, y_)
#		draw(x, y)
#		draw(x_, y_)
		u(x) ; u(y)
		u(x_) ; u(y_) ; u(aweight) ; u(a1weight)
		#draw(x*aweight + x_*a1weight, y*aweight + y_*a1weight)
		let(w, or/240 * wavg(planet_r[i-1], planet_r[i], p))
		w = bound(w, 1, 3)
		wide_line(lx, ly, x*aweight + x_*a1weight, y*aweight + y_*a1weight, w)
		p+=dp

wide_line(real x0, real y0, real x1, real y1, real w)
	width(w)
	unit(x1-x0, y1-y0, ux, uy)
	ux *= w/2 ; uy *= w/2
	line(x0-ux, y0-uy, x1+ux, y1+uy)
	move2(x0, y0, x1, y1)
	thin()

def unit(dx, dy, ux, uy)
	let(d, hypot(dx, dy))
	let(ux, dx / d)
	let(uy, dy / d)

def wavg(a, b, w) a*(1-w) + b*w

def u(v) v=v

def curves()
	.
		# connect the planets with a curve...
		width(2)
		planet_pos(0, or, oa, x0, y0)
		
		eachplanet(i)
			if i == 0
				continue
			planet_pos(i, r, a, x1, y1)
			curve(i, x0, y0, or, oa, r, a, 0)
			curve(i, x0, y0, or, oa, r, a, 1)
			x0 = x1 ; y0 = y1
			or = r ; oa = a

#x=x ; y=y  # keep gcc happy  IDEA for macros; omit to do an op if the result isn't ever used;
	   #                 this would keep gcc happy too!

curve(int i, real x0, real y0, real or, real oa, real r, real a, boolean golong)
	real da = a - oa
	da = rmod(da, 360)
	real da1 = -(360-da)
	if (da > 180) ^ golong
		swap(da, da1)

	move(x0, y0)
	int steps = 1 + (int)fabs(da) / 5 #(150/r) # equal size steps
	da /= steps
	real dr = (r - or) / steps
	real p = 0.0
	real dp = 1.0/steps
	for ; steps > 0; --steps
#			if steps % 2
		rb(-60 + (i+p)*330/8)
#			else
#				black()
		oa += da
		or += dr
		polar_to_rec_clock(0, 0, oa, or, x, y)
		draw(x, y)
		p+=dp

# need to be able to define macros from within a macro

def curve_orig()
	.
		# connect the planets with a curve...
		width(2)
		planet_pos(0, or, oa, x, y)
		move(x, y)
		eachplanet(i)
			if i == 0
				continue
			planet_pos(i, r, a, x, y)
			x=x ; y=y  # keep gcc happy
			real da = a - oa
			da = rmod(da, 360)
			if da > 180
				da = -(360-da)
			int steps = 1 + (int)fabs(da) / 5 #(150/r) # equal size steps
			da /= steps
			real dr = (r - or) / steps
			real p = 0.0
			real dp = 1.0/steps
			for ; steps > 0; --steps
#				if steps % 2
				rb(-60 + (i+p)*330/8)
#				else
#					black()
				oa += da
				or += dr
				polar_to_rec_clock(0, 0, oa, or, x, y)
				draw(x, y)
				p+=dp
			
			or = r ; oa = a

def Toss()
	if toss()

# TODO sun is planet[0] !

def starburst()
	.
		# connect the planets with a curve...
		width(2)
		eachplanet(j)
			if j != earth
				connect(0, earth, j)
		connectsun(1, earth)
		#planet_pos(earth, r0, a0, x0, y0)
		#connect_grey(1, x0, y0, 0, 0)
		#connect_grey(1, 0, 0, x0, y0)
#			eachplanet(i)
#				if i > j #&& i != earth && j != earth
#		eachplanet(i)
#			connect(earth, i)

#		eachstar(s)
#			connectstar(s)

def connect(strong, A, B)
	planet_pos(A, r0, a0, x0, y0)
	planet_pos(B, r1, a1, x1, y1)
	connect_grey(strong, x0, y0, x1, y1)

def connectsun(strong, A)
	planet_pos(A, r0, a0, x0, y0)
	let(x1, 0.0) ; let(y1, 0.0)
	connect_grey(strong, x0, y0, x1, y1)

def connectstar(S)
	star_pos(S, x1, y1)
	connect_grey(0, 0, 0, x1, y1)

# IDEA - once have auto decl, won't need to worry about whether decl'd or not

def greypowhigh 6
def greypowlow 2
def burst_len 100
def connect_grey(strong, x0, y0, x1, y1)
	move(x0, y0)
	let(my(d), dist(x0, y0, x1, y1))
	let(my(bl), 1/sqr(my(d)) * 1000000)
	my(bl) = bound(my(bl), 0, my(d))
	x1 = x0 + (x1-x0) * my(bl)/my(d)
	y1 = y0 + (y1-y0) * my(bl)/my(d)
	my(d) = my(bl)
#	let(my(d), dist(x0, x0, x1, y1))
	for(my(p), 0.0, 1, 1/my(d))
		let(xx, x0 + (x1-x0)*my(p))
		let(yy, y0 + (y1-y0)*my(p))
#		if toss()
#			black()
#		else
#			white()
#		rb(-60 + (i*R/r)*330/8.0)
		real v
		if !anim || toss()
			#rb(-60 + p*i*330/8.0)
			if strong
				v = pow(1-my(p), greypowlow)
			else
				v = pow(1-my(p), greypowhigh)
		else
			v = 0
#		if v > 0.01 && p*d > 10 && (1-p)*d > 10
	#	if v > 0.01 #p*d > 10 && (1-p)*d > 10 #&& v > 0.01
		gr(v)
		draw(xx, yy)
#		else
#			move(xx, yy)

def bound(a, low, high) a < low ? low : a > high ? high : a


colour gr[256]

grey_init()
	for(i, 0, 256)
		gr[i] = grey(i/256.0)

def gr(p) col(gr[bound((int)(p*256), 0, 256)])
def grey(p) rgb(p, p, p*.95+.05)

real dt = secs_in_day / 2 #/ 4 #* 2 #/ 24

# TODO put in "colours" file
colour spaceblue

def gsay_date(t)
	# print the date
	decl(currenttime, datetime)
	Localtime(t, currenttime)
	cstr birth_t_cstr = Timef(currenttime, dt_format)
	gsay(birth_t_cstr)
	Free(birth_t_cstr)

def gsay_place(p)
	# print the place
	cstr NS
	cstr EW
	int ns = p->ns
	int ew = mod(p->ew, 360)
	if ew > 180
		ew -= 360

	# FIXME have N/S E/W in place (a separate sign)
	# otherwise ~ equator there are problems
	if ns >= 0
		NS = "N"
	else
		NS = "S"
		ns = -ns
	if ew >= 0
		EW = "E"
	else
		EW = "W"
		ew = -ew

	# todo mod to a - to + range...
	gsayf("%d:%d'%d\"%s  %d:%d'%d\"%s", ns, p->ns_min, p->ns_sec, NS, ew, p->ew_min, p->ew_sec, EW)

<b/gr.bh>
<b/util.bh>
<b/m.bh>
<b/main.bh>
<b/time.bh>
<b/place.bh>
<b/error.bh>
<b/alloc.bh>
<b/key.bh>
!)@(#*$&%^ ./lattice
#!/lang/b
use b

Main()
	space()
#	space(midnightblue)
#	space(800, 600)
#	gr_delay(0.5)

	num max = 400
	num min = 30

	num a
	num da = 0.2
	for a = 0; ; a+=da
		zoom((Cos(a*5)+1)/2*(max-min)+min)
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		csleep(1.0/70.0)
		Paint()
		da *= 1.0005

num rt3
num r1, r2

def draw_lattice()
#	Printf("%f ", rtime())

	rt3 = sqrt(3.0)

	r1 = 1
	r2 = rt3

#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+2)
	int yc = xc

	move()
	let(o, get_pos())
	fd(1)
	let(x1, get_pos())
	set_pos(o)
	lt(60)
	fd(1)
	let(y1, get_pos())
	set_pos(o)
	draw()

	num A = pow((a-360/5*2.4), 1.1)

	for(x, -xc, xc)
		for(y, -yc, yc)
			int X = x - Div(y, 2)
			int Y = y
			lx = x1.lx*X + y1.lx*Y
			ly = x1.ly*X + y1.ly*Y
			
			turtle_branch()
#				move()
#				fd(X)
#				lt(60)
#				fd(Y)
#				rt(60)
#				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(X-Y, 3) == 0
					int Y1 = (Y-X) / 3
					int X1 = (2*X + Y) / 3
					int xm = mod(X1, 2)
					int ym = mod(Y1, 2)
					int n = 2*xm+ym
					if a < 360/5*1.4
						draw_star()
					 else
						if n == 0
							if a >= 360/5*2.4
								rt(ssqrt(5-hypot(x, y))*A)
							fill_star(n)
#					move() ; north(font_height()/2)
#					gprintf("%d,%d", X, Y)
#					gnl()
#					gprintf("%d,%d", X1, Y1)

#	Sayf("%f", rtime())

	if a >= 360/5*3.4
		min = 30 - (a-360/5*5.4)/(360/5) * 2
		max = 400 - (a-360/5*5.4)/(360/5) * 30
		if min < 15
			min = 15
		if max < 20
			max = 20

int star_colors[][12] =
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 },
	{ 7, 6, 9, 8, 11, 10, 1, 0, 3, 2, 5, 4 },
	{ 7, 6, 9, 8, 4, 5, 1, 0, 3, 2, 10, 11 },
	{ 0, 1, 2, 3, 11, 10, 6, 7, 8, 9, 5, 4 },

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		lt(60)
	lt(30)
	repeat(6)
		turtle_branch()
			fd(rt3/2+a_pixel)
		lt(60)
	rt(30)

fill_star(int n)
	move()
	let(o, get_pos())
	fd(r1)
	let(a, get_pos())
	for(i, 0, 6)
		int c = star_colors[n][i*2]
		col(rb[c*30])
		set_pos(o)
		lt(60*i+30)
		fd(r2)
		let(b, get_pos())
		triangle(a, o, b)
		c = star_colors[n][i*2+1]
		col(rb[c*30])
		set_pos(o)
		lt(60*i+60)
		fd(r1)
		a = get_pos()
		triangle(b, o, a)
	set_pos(o)
	draw()

!)@(#*$&%^ ./lattice.d/1
#!/lang/b
use b

Main()
	space(800, 600)
	zoom(40)

	num a
	for a = 0; ; a+=0.5
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			turtle_branch()
				move()
				fd(x*rt3/2)
				lt(90)
				if x%2
					fd(0.5)
				fd(y)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(y-mod(x,2),3)==0
					draw_star()
				 else
					point()
#	Sayf("%f", rtime())

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)
!)@(#*$&%^ ./lattice.d/2
#!/lang/b
use b

Main()
	space(midnightblue)
	zoom(40)

	num a
	for a = 0; ; a+=0.5
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			turtle_branch()
				move()
				fd(x*rt3/2)
				lt(90)
				if x%2
					fd(0.5)
				fd(y)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(y-mod(x,2),3)==0
					fill_star()
#	Sayf("%f", rtime())

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)

def fill_star()
	move()
	let(o, get_pos())
	fd(1)
	let(a, get_pos())
	for(i, 0, 6)
		col(rb[i*60])
		set_pos(o)
		rt(60*i)
		rt(30)
		fd(rt3/2)
		let(b, get_pos())
		triangle(a, o, b)
		col(rb[i*60+30])
		set_pos(o)
		rt(60*i)
		rt(60)
		fd(1)
		a = get_pos()
		triangle(b, o, a)

!)@(#*$&%^ ./lattice.d/3
#!/lang/b
use b

Main()
	space(midnightblue)
	zoom(40)

	num a
	for a = 0; ; a+=0.5
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			turtle_branch()
				move()
				fd(x*rt3/2)
				lt(90)
				if x%2
					fd(0.5)
				fd(y)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(y-mod(x,2),3)==0
#					draw_star()
					rt(30*x+y)
					fill_star()
#				 else
#					point()
#	Sayf("%f", rtime())

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)

def fill_star()
	move()
	let(o, get_pos())
	fd(1)
	let(a, get_pos())
	for(i, 0, 6)
		col(rb[i*60])
		set_pos(o)
		rt(60*i)
		rt(30)
		fd(rt3/2)
		let(b, get_pos())
		triangle(a, o, b)
		col(rb[i*60+30])
		set_pos(o)
		rt(60*i)
		rt(60)
		fd(1)
		a = get_pos()
		triangle(b, o, a)

!)@(#*$&%^ ./lattice.d/4
#!/lang/b
use b

Main()
	space(midnightblue)
	zoom(40)

	num a
	for a = 0; ; a+=0.5
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			turtle_branch()
				move()
				fd(x*rt3/2)
				lt(90)
				if x%2
					fd(0.5)
				fd(y)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(y-mod(x,2),3)==0
#					rt(30*x+y)
					fill_star()
#	Sayf("%f", rtime())

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)

def fill_star()
	num unit = 0.9
	move()
	let(o, get_pos())
	fd(unit)
	let(a, get_pos())
	for(i, 0, 6)
		col(rb[i*60])
		set_pos(o)
		rt(60*i)
		rt(30)
		fd(rt3/2 * unit)
		let(b, get_pos())
		triangle(a, o, b)
		col(rb[i*60+30])
		set_pos(o)
		rt(60*i)
		rt(60)
		fd(unit)
		a = get_pos()
		triangle(b, o, a)
!)@(#*$&%^ ./lattice.d/5
#!/lang/b
use b

Main()
	space(midnightblue)
	zoom(40)

	num a
	for a = 0; ; a+=0.5
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()
#		Sleep(100)

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			turtle_branch()
				move()
				fd(x*rt3/2)
				lt(90)
				if x%2
					fd(0.5)
				fd(y)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(y-mod(x,2),3)==0
					rt(a*hypot(lx,ly))
#					rt(60*x/2+y/2)
					fill_star()
#	Sayf("%f", rtime())

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)

def fill_star()
	num unit = 0.9
	move()
	let(o, get_pos())
	fd(unit)
	let(a, get_pos())
	for(i, 0, 6)
		col(rb[i*60])
		set_pos(o)
		rt(60*i)
		rt(30)
		fd(rt3/2 * unit)
		let(b, get_pos())
		triangle(a, o, b)
		col(rb[i*60+30])
		set_pos(o)
		rt(60*i)
		rt(60)
		fd(unit)
		a = get_pos()
		triangle(b, o, a)
!)@(#*$&%^ ./lattice.d/6
#!/lang/b
use b

Main()
	space(midnightblue)
	zoom(40)

	num a
	for a = 0; ; a+=0.5
		move(0, 0)
		east()
		lt(a)
		clear()
		draw_lattice()
		Paint()
#		Sleep(100)

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			turtle_branch()
				move()
				fd(x*rt3/2)
				lt(90)
				if x%2
					fd(0.5)
				fd(y)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(y-mod(x,2),3)==0
					rt(a*Cos(hypot(lx,ly)*720/xc)*5)
					num unit = 0.6
#					rt(60*x/2+y/2)
					fill_star(unit)
#	Sayf("%f", rtime())

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)

def fill_star(unit)
	move()
	let(o, get_pos())
	fd(unit)
	let(a, get_pos())
	for(i, 0, 6)
		col(rb[i*60])
		set_pos(o)
		rt(60*i)
		rt(30)
		fd(rt3/2 * unit * .65)
		let(b, get_pos())
		triangle(a, o, b)
		col(rb[i*60+30])
		set_pos(o)
		rt(60*i)
		rt(60)
		fd(unit)
		a = get_pos()
		triangle(b, o, a)
!)@(#*$&%^ ./lattice.d/7
#!/lang/b
use b

num rt3
Main()
	space(midnightblue)
	gprint_anchor(0, 0)
	zoom(40)
	rt3 = sqrt(3.0)

	num a = -360
	num da = 0
	num dda = 0.01

	repeat
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()
		a += da
		if a > 0
			dda = -0.01
		 eif a < 0
			dda = 0.01
		da += dda

def draw_lattice()
#	Printf("%f ", rtime())
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+1)
	int yc = xc
	for(pass, 0, 4)
		which pass
		0	blue()
		1	white()
		2	black()
		3	green()
		for(x, -xc, xc)
			for(y, -yc, yc)
				int X = x - Div(y, 2)
				int Y = y
				turtle_branch()
					move()
					fd(X)
					lt(60)
					fd(Y)
					draw()
					if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
						continue
					if mod(X-Y, 3) == 0
						which pass
						0	draw_star(1)
						1	circle(0.5)
						2	circle(rt3/2)
					 else
						which pass
						2	disc(0.2)
						3	gprintf("%d,%d", X, Y)
	#	Sayf("%f", rtime())

draw_star(num unit)
	repeat(6)
		turtle_branch()
			fd(unit)
		rt(60)
	rt(30)
	repeat(3)
		turtle_branch()
			fd(rt3*unit)
		rt(60)
!)@(#*$&%^ ./lattice.d/8
#!/lang/b
use b

Main()
	space(midnightblue)
#	gr_delay(0.5)

	num a
	for a = 0; ; a+=0.2
		zoom((Cos(a*5)+1)/2*570+30)
		move(0, 0)
		east()
		rt(a)
		clear()
		draw_lattice()
		Paint()

def draw_lattice()
#	Printf("%f ", rtime())
	num rt3 = sqrt(3.0)
#	int xc = Floor(w_2/(sc*rt3/2)+1)
#	int yc = Floor(h_2/sc+1)
	int xc = Floor(hypot(w_2, h_2)/(sc*rt3/2)+2)
	int yc = xc
	for(x, -xc, xc)
		for(y, -yc, yc)
			int X = x - Div(y, 2)
			int Y = y
			turtle_branch()
				move()
				fd(X)
				lt(60)
				fd(Y)
				rt(60)
				draw()
				if fabs(lx) > w_2+sc*3 || fabs(ly) > h_2+sc*3
					continue
				if mod(X-Y, 3) == 0
					int Y1 = (Y-X) / 3
					int X1 = (2*X + Y) / 3
					int xm = mod(X1, 2)
					int ym = mod(Y1, 2)
					int n = 2*xm+ym
					fill_star(n)
#					move() ; north(font_height()/2)
#					gprintf("%d,%d", X, Y)
#					gnl()
#					gprintf("%d,%d", X1, Y1)

#	Sayf("%f", rtime())

int star_colors[][12] =
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 },
	{ 7, 6, 9, 8, 11, 10, 1, 0, 3, 2, 5, 4 },
	{ 7, 6, 9, 8, 4, 5, 1, 0, 3, 2, 10, 11 },
	{ 0, 1, 2, 3, 11, 10, 6, 7, 8, 9, 5, 4 },
		

def draw_star()
	repeat(6)
		turtle_branch()
			fd(1)
		rt(60)
	rt(30)
	repeat(6)
		turtle_branch()
			fd(rt3)
		rt(60)

def fill_star(n)
	num unit = 1
	move()
	let(o, get_pos())
	fd(unit)
	let(a, get_pos())
	for(i, 0, 6)
		int c = star_colors[n][i*2]
		col(rb[c*30])
		set_pos(o)
		lt(60*i)
		lt(30)
		fd(rt3/2*unit)
		let(b, get_pos())
		triangle(a, o, b)
		c = star_colors[n][i*2+1]
		col(rb[c*30])
		set_pos(o)
		lt(60*i)
		lt(60)
		fd(unit)
		a = get_pos()
		triangle(b, o, a)
	set_pos(o)
!)@(#*$&%^ ./mandelbrot
#!/lang/b
# ./mandelbrot -.74364386269 .13182590271 .00000006763 16000 1000
# ./mandelbrot -.743643135 .131825963 .0000054855 16000 400 5
use b

cstr usage[] = { "x y r max_i rb_i payg w h", NULL }

def blank_colour 1

def paint_as_you_go 1
int payg = 5

Main()
	num outside = 16 # 4
	num outside2 = outside*outside
	num out_square = sqrt(outside2/2)
	num ox = -0.5, oy = 0, r = 1.5
	long max_i = 1024, rb_i = 30, W=0, H=0
	getargs(float, ox, oy, r)
	getargs(long, max_i, rb_i, payg, W, H)
	if args
		usage()
	if W
		space(W, H, blank_colour)
	 else
		space(blank_colour)
	pr(cstr, program)
	pr(float, ox, oy, r)
	Pr(long, max_i, rb_i, payg, w, h)
	bm_start()
	rainbow_init()
	with_pixel_type(mandelbrot)
	Paint()
	bm(program)


typedef long pixel_type  # the nested macros lose expansions

def mandelbrot(pixel_type)
	int counter = 0
	num d = 2*r/h, x0 = ox-d*w_2, y0 = oy+d*h_2
	cmplx c0 = x0 + y0*I
	smooth_init()
	pointi2 seeds[(w+h-2)*2*5]
	int i=0
	for(x, 0, w)
		seeds[i].x[0] = x
		seeds[i].x[1] = 0
		seeds[i+1].x[0] = x
		seeds[i+1].x[1] = h-1
		i+=2
	for(y, 1, h-1)
		seeds[i].x[0] = 0
		seeds[i].x[1] = y
		seeds[i+1].x[0] = w-1
		seeds[i+1].x[1] = y
		i+=2

	flood_8(seeds, 0, 0, w, h, blank, test, fill)
	for_pixels(px)
		if *px == blank_colour
			*px = 0

def flood_8(seeds, x0, y0, x1, y1, blank, test, fill)
	int s = sizeof(seeds) / sizeof(*seeds)
	int n = i
	i = 0
	while(i!=n)
		pointi2 *p = seeds + i
		pointi2 *new
		++i
		if i == s
			i = 0
		if blank(*p)
			fill(*p)
			if n == s
				n = 0
			new = seeds + n
			*new = *p
			boolean t
			if p->x[0] > x0
				new->x[0] = p->x[0] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1
				new->x[0] = p->x[0] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			new->x[0] = p->x[0]
			if p->x[1] > y0
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[1] < y1-1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] > x0 && p->x[1] > y0
				new->x[0] = p->x[0] - 1
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] > x0 && p->x[1] < y1-1
				new->x[0] = p->x[0] - 1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1 && p->x[1] < y1-1
				new->x[0] = p->x[0] + 1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1 && p->x[1] > y0
				new->x[0] = p->x[0] + 1
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)

def flood_test_push(p, new, blank, test, t, seeds)
	if blank(*new)
		test(t, *p, *new)
		if t
			++n
			if n == s
				n = 0
			new = seeds + n
			*new = *p

def blank(p) *(pixel_type*)pixel(vid, p.x[0], p.x[1]) == blank_colour
def test(t, a, b)
	t = *(pixel_type*)pixel(vid, a.x[0], a.x[1]) != 0
def fill(p)
	pixel_type *px = (pixel_type *)pixel(vid, p.x[0], p.x[1])
	cmplx c = c0 + d*p.x[0] - d*p.x[1]*I
	cmplx W = c
#	i=0
	long it
	for it=0; it < max_i; ++it
		W = W*W + c
#		if cabs(W) > outside
#		if (creal(W) < -out_square || creal(W) > out_square || cimag(W) < -out_square || cimag(W) > out_square) && cabs2(W) > outside2
#		if (fabs(creal(W)) > out_square || fabs(cimag(W)) > out_square) && cabs2(W) > outside2
		num re = fabs(creal(W))
		num im = fabs(cimag(W))
		if (re > out_square || im > out_square) && (re*re + im*im) > outside2
			break
	smooth_i(it, W)
#	*px = it < max_i*smooth_n ? rb[it*359 / (rb_i*smooth_n) % 360] : black
	*px = it < max_i*smooth_n ? rb[it*359 / (rb_i*smooth_n) % 360] : black
#	*px = i < max_i ? rb[i*359 / rb_i % 360] : black
	if paint_as_you_go && payg && counter++ > (n-i+s) % s * payg
		counter = 0
		Paint()

def smooth_init()
	int smooth_n = 32 # 8
	num smooth_fac = pow(2, 1.0/smooth_n)
	num smooth_outside[smooth_n]
	for(j, 0, smooth_n)
		smooth_outside[j] = pow(outside, pow(smooth_fac, j))

def smooth_i(i, W)
	num a = cabs(W)
	i = i * smooth_n + smooth_n-1
	for(j, 1, smooth_n)
		if a < smooth_outside[j]
			break
		--i
!)@(#*$&%^ ./mandelbrot.d/2
#!/lang/b
# ./mandelbrot -.74364386269 .13182590271 .00000006763 16000 1000 100 100
# ./mandelbrot -.743643135 .131825963 .0000054855 16000 400
use b

cstr usage[] = { "x y r max_i rb_i payg w h", NULL }

def blank_colour 1

def paint_as_you_go 1
int payg = 5

Main()
	num outside = 4 # 16
	num outside2 = outside*outside
	num out_square = sqrt(outside2/2)
	long i
	num ox = -0.5, oy = 0, r = 1.5
	long max_i = 1024, rb_i = 30, W=0, H=0
	getargs(float, ox, oy, r)
	getargs(long, max_i, rb_i, payg, W, H)
	if args
		usage()
	pr(float, ox, oy, r)
	Pr(long, max_i, rb_i, W, H)
	if W
		space(W, H, blank_colour)
	 else
		typedef long pixel_type  # the nested macros lose expansions
		space(blank_colour)
	bm_start()
	rainbow_init()
	with_pixel_type(mandelbrot)
	Paint()
	bm(program)


typedef long pixel_type  # the nested macros lose expansions

def mandelbrot(pixel_type)
	int counter = 0
	num d = 2*r/h, x0 = ox-d*w_2, y0 = oy+d*h_2
	cmplx c0 = x0 + y0*I
	smooth_init()
	new(seeds, deq, pointi2, (w+h) * 2)
	pointi2 p
	for(x, 0, w)
		p.x[0] = x
		p.x[1] = 0
		deq_push(seeds, p)
		p.x[1] = h-1
		deq_push(seeds, p)
	for(y, 1, h-1)
		p.x[0] = 0
		p.x[1] = y
		deq_push(seeds, p)
		p.x[0] = w-1
		deq_push(seeds, p)

	flood_4(seeds, 0, 0, w, h, blank, test, fill)
	for_pixels(px)
		if *px == blank_colour
			*px = 0

def flood_4(seeds, x0, y0, x1, y1, blank, test, fill)
	while(deqlen(seeds))
		pointi2 p
		pointi2 new
		deq_shift(seeds, p)
		if blank(p)
			fill(p)
			new = p
			boolean t
			if p.x[0] > x0
				new.x[0] = p.x[0] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p.x[0] < x1-1
				new.x[0] = p.x[0] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			new.x[0] = p.x[0]
			if p.x[1] > y0
				new.x[1] = p.x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p.x[1] < y1-1
				new.x[1] = p.x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)

def flood_test_push(p, new, blank, test, t, seeds)
	if blank(new)
		test(t, p, new)
		if t
			deq_push(seeds, new)

def blank(p) *(pixel_type*)pixel(vid, p.x[0], p.x[1]) == blank_colour
def test(t, a, b)
	t = *(pixel_type*)pixel(vid, a.x[0], a.x[1]) != 0
def fill(p)
	pixel_type *px = (pixel_type *)pixel(vid, p.x[0], p.x[1])
	cmplx c = c0 + d*p.x[0] - d*p.x[1]*I
	cmplx W = c
#	i=0
	for i=0; i < max_i; ++i
		W = W*W + c
#		if cabs(W) > outside
#		if (creal(W) < -out_square || creal(W) > out_square || cimag(W) < -out_square || cimag(W) > out_square) && cabs2(W) > outside2
#		if (fabs(creal(W)) > out_square || fabs(cimag(W)) > out_square) && cabs2(W) > outside2
		num re = fabs(creal(W))
		num im = fabs(cimag(W))
		if (re > out_square || im > out_square) && (re*re + im*im) > outside2
			break
	smooth_i(i, W)
	*px = i < max_i*smooth_n ? rb[i*359 / (rb_i*smooth_n) % 360] : black
#	*px = i < max_i ? rb[i*359 / rb_i % 360] : black
	if paint_as_you_go && payg && counter++ > veclen(seeds)*payg
		counter = 0
		Paint()

def smooth_init()
	int smooth_n = 8 # 32
	num smooth_fac = pow(2, 1.0/smooth_n)
	num smooth_outside[smooth_n]
	for(j, 0, smooth_n)
		smooth_outside[j] = pow(outside, pow(smooth_fac, j))

def smooth_i(i, W)
	num a = cabs(W)
	i = i * smooth_n + smooth_n-1
	for(j, 1, smooth_n)
		if a < smooth_outside[j]
			break
		--i

def cabs2(w) creal(w*(creal(w)-cimag(w)*I))
!)@(#*$&%^ ./mandelbrot.d/3
#!/lang/b
# ./mandelbrot -.74364386269 .13182590271 .00000006763 16000 1000
# ./mandelbrot -.743643135 .131825963 .0000054855 16000 400 5
use b

cstr usage[] = { "x y r max_i rb_i payg w h", NULL }

def blank_colour 1

def paint_as_you_go 1
int payg = 5

Main()
	num outside = 4 # 16
	num outside2 = outside*outside
	num out_square = sqrt(outside2/2)
	long i
	num ox = -0.5, oy = 0, r = 1.5
	long max_i = 1024, rb_i = 30, W=0, H=0
	getargs(float, ox, oy, r)
	getargs(long, max_i, rb_i, payg, W, H)
	if args
		usage()
	pr(float, ox, oy, r)
	Pr(long, max_i, rb_i, W, H)
	if W
		space(W, H, blank_colour)
	 else
		space(blank_colour)
	bm_start()
	rainbow_init()
	with_pixel_type(mandelbrot)
	Paint()
	bm(program)


typedef long pixel_type  # the nested macros lose expansions

def mandelbrot(pixel_type)
	int counter = 0
	num d = 2*r/h, x0 = ox-d*w_2, y0 = oy+d*h_2
	cmplx c0 = x0 + y0*I
	smooth_init()
	pointi2 seeds[(w+h-2)*2*5]
	pointi2 p
	int i=0
	for(x, 0, w)
		seeds[i].x[0] = x
		seeds[i].x[1] = 0
		seeds[i+1].x[0] = x
		seeds[i+1].x[1] = h-1
		i+=2
	for(y, 1, h-1)
		seeds[i].x[0] = 0
		seeds[i].x[1] = y
		seeds[i+1].x[0] = w-1
		seeds[i+1].x[1] = y
		i+=2

	flood_4(seeds, 0, 0, w, h, blank, test, fill)
	for_pixels(px)
		if *px == blank_colour
			*px = 0

def flood_4(seeds, x0, y0, x1, y1, blank, test, fill)
	int s = sizeof(seeds) / sizeof(*seeds)
	int n = i
	i = 0
	while(i!=n)
		pointi2 *p = seeds + i
		pointi2 *new
		++i
		if i == s
			i = 0
		if blank(*p)
			fill(*p)
			if n == s
				n = 0
			new = seeds + n
			*new = *p
			boolean t
			if p->x[0] > x0
				new->x[0] = p->x[0] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1
				new->x[0] = p->x[0] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			new->x[0] = p->x[0]
			if p->x[1] > y0
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[1] < y1-1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)

def flood_test_push(p, new, blank, test, t, seeds)
	if blank(*new)
		test(t, *p, *new)
		if t
			++n
			if n == s
				n = 0
			new = seeds + n
			*new = *p

def blank(p) *(pixel_type*)pixel(vid, p.x[0], p.x[1]) == blank_colour
def test(t, a, b)
	t = *(pixel_type*)pixel(vid, a.x[0], a.x[1]) != 0
def fill(p)
	pixel_type *px = (pixel_type *)pixel(vid, p.x[0], p.x[1])
	cmplx c = c0 + d*p.x[0] - d*p.x[1]*I
	cmplx W = c
#	i=0
	long it
	for it=0; it < max_i; ++it
		W = W*W + c
#		if cabs(W) > outside
#		if (creal(W) < -out_square || creal(W) > out_square || cimag(W) < -out_square || cimag(W) > out_square) && cabs2(W) > outside2
#		if (fabs(creal(W)) > out_square || fabs(cimag(W)) > out_square) && cabs2(W) > outside2
		num re = fabs(creal(W))
		num im = fabs(cimag(W))
		if (re > out_square || im > out_square) && (re*re + im*im) > outside2
			break
	smooth_i(it, W)
	*px = it < max_i*smooth_n ? rb[it*359 / (rb_i*smooth_n) % 360] : black
#	*px = i < max_i ? rb[i*359 / rb_i % 360] : black
	if paint_as_you_go && payg && counter++ > (n-i+s) % s * payg
		counter = 0
		Paint()

def smooth_init()
	int smooth_n = 8 # 32
	num smooth_fac = pow(2, 1.0/smooth_n)
	num smooth_outside[smooth_n]
	for(j, 0, smooth_n)
		smooth_outside[j] = pow(outside, pow(smooth_fac, j))

def smooth_i(i, W)
	num a = cabs(W)
	i = i * smooth_n + smooth_n-1
	for(j, 1, smooth_n)
		if a < smooth_outside[j]
			break
		--i

def cabs2(w) creal(w*(creal(w)-cimag(w)*I))
!)@(#*$&%^ ./mandelbrot.d/d1
#!/lang/b
# ./d1 -1.635 1.18 0.03 1024 30 5
use b

cstr usage[] = { "x y r max_i rb_i payg w h", NULL }

def blank_colour 1

def paint_as_you_go 1
int payg = 5

Main()
	num outside = 16 # 4
	num outside2 = outside*outside
	num out_square = sqrt(outside2/2)
	long i
	num ox = -0.5, oy = 0, r = 1.5
	long max_i = 1024, rb_i = 30, W=0, H=0
	getargs(float, ox, oy, r)
	getargs(long, max_i, rb_i, payg, W, H)
	if args
		usage()
	if W
		space(W, H, blank_colour)
	 else
		space(blank_colour)
	pr(cstr, program)
	pr(float, ox, oy, r)
	Pr(long, max_i, rb_i, payg, w, h)
	bm_start()
	rainbow_init()
	with_pixel_type(mandelbrot)
	Paint()
	bm(program)


typedef long pixel_type  # the nested macros lose expansions

def mandelbrot(pixel_type)
	int counter = 0
	num d = 2*r/h, x0 = ox-d*w_2, y0 = oy+d*h_2
	cmplx c0 = x0 + y0*I
	smooth_init()
	pointi2 seeds[(w+h-2)*2*5]
	pointi2 p
	int i=0
	for(x, 0, w)
		seeds[i].x[0] = x
		seeds[i].x[1] = 0
		seeds[i+1].x[0] = x
		seeds[i+1].x[1] = h-1
		i+=2
	for(y, 1, h-1)
		seeds[i].x[0] = 0
		seeds[i].x[1] = y
		seeds[i+1].x[0] = w-1
		seeds[i+1].x[1] = y
		i+=2

	flood_8(seeds, 0, 0, w, h, blank, test, fill)
	for_pixels(px)
		if *px == blank_colour
			*px = 0

def flood_8(seeds, x0, y0, x1, y1, blank, test, fill)
	int s = sizeof(seeds) / sizeof(*seeds)
	int n = i
	i = 0
	while(i!=n)
		pointi2 *p = seeds + i
		pointi2 *new
		++i
		if i == s
			i = 0
		if blank(*p)
			fill(*p)
			if n == s
				n = 0
			new = seeds + n
			*new = *p
			boolean t
			if p->x[0] > x0
				new->x[0] = p->x[0] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1
				new->x[0] = p->x[0] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			new->x[0] = p->x[0]
			if p->x[1] > y0
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[1] < y1-1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] > x0 && p->x[1] > y0
				new->x[0] = p->x[0] - 1
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] > x0 && p->x[1] < y1-1
				new->x[0] = p->x[0] - 1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1 && p->x[1] < y1-1
				new->x[0] = p->x[0] + 1
				new->x[1] = p->x[1] + 1
				flood_test_push(p, new, blank, test, t, seeds)
			if p->x[0] < x1-1 && p->x[1] > y0
				new->x[0] = p->x[0] + 1
				new->x[1] = p->x[1] - 1
				flood_test_push(p, new, blank, test, t, seeds)

def flood_test_push(p, new, blank, test, t, seeds)
	if blank(*new)
		test(t, *p, *new)
		if t
			++n
			if n == s
				n = 0
			new = seeds + n
			*new = *p

def blank(p) *(pixel_type*)pixel(vid, p.x[0], p.x[1]) == blank_colour
def test(t, a, b)
	t = *(pixel_type*)pixel(vid, a.x[0], a.x[1]) != 0
def fill(p)
	pixel_type *px = (pixel_type *)pixel(vid, p.x[0], p.x[1])
	cmplx c = c0 + d*p.x[0] - d*p.x[1]*I
	cmplx W = c
#	i=0
	long it
	for it=0; it < max_i; ++it
		W = csin(W)*W + c
#		if cabs(W) > outside
#		if (creal(W) < -out_square || creal(W) > out_square || cimag(W) < -out_square || cimag(W) > out_square) && cabs2(W) > outside2
#		if (fabs(creal(W)) > out_square || fabs(cimag(W)) > out_square) && cabs2(W) > outside2
		num re = fabs(creal(W))
		num im = fabs(cimag(W))
		if (re > out_square || im > out_square) && (re*re + im*im) > outside2
			break
	smooth_i(it, W)
#	*px = it < max_i*smooth_n ? rb[it*359 / (rb_i*smooth_n) % 360] : black
	*px = it < max_i*smooth_n ? rb[it*359 / (rb_i*smooth_n) % 360] : black
#	*px = i < max_i ? rb[i*359 / rb_i % 360] : black
	if paint_as_you_go && payg && counter++ > (n-i+s) % s * payg
		counter = 0
		Paint()

def smooth_init()
	int smooth_n = 32 # 8
	num smooth_fac = pow(2, 1.0/smooth_n)
	num smooth_outside[smooth_n]
	for(j, 0, smooth_n)
		smooth_outside[j] = pow(outside, pow(smooth_fac, j))

def smooth_i(i, W)
	num a = cabs(W)
	i = i * smooth_n + smooth_n-1
	for(j, 1, smooth_n)
		if a < smooth_outside[j]
			break
		--i

def cabs2(w) creal(w*(creal(w)-cimag(w)*I))
!)@(#*$&%^ ./pretty.d/pretty-orig
#!/lang/b

Main()
	paper(1280, 800, black)

	colour rb[360]
	for(i, 0, 360)
		rb[i] = rainbow(i)

	for(x, -w_2, w_2)
		for(y, -h_2, h_2)
			int r = hypot(x, y)
			int a = mod(Atan2(y, x)+Sin(r*r/100)*50, 360)

			col(rb[a])
			point(x, y)
		Paint()

use b
!)@(#*$&%^ ./rainbow
#!/lang/b

Main()
	paper(640, 480)

	dt = angle2rad(1)

	num r = 480/2*.9
	num a = 0

	spectrum()
#	cycle()


def cycle()
	repeat
		spectrum()
		num power
#		spin()
		pulse_spin(red)
		pulse_spin(green)
		pulse_spin(blue)

def X Sin(a)*r
def Y Cos(a)*r
  # these REALLY want to be local macros!

def spectrum()
	move(X, Y)
	for a = 0 ; a<360.5 ; ++a
		rainbow(a+0.5)
		move(0, 0)
		triangle(X, Y)
	Paint()
	Sleep(0.01)

num dt

def spin()
	rb_red_angle += 1.6*dt
	rb_green_angle += 2*dt
	rb_blue_angle += 1*dt

def pulse(which)
	for power=0; power < 360.1; power += 5
		rb_^^which^^_power = (Cos(power)+1)/2 * 0.8
		spectrum()

def pulse_spin(which)
	pulse(which)
		spin()

use main
use m
use gr
use error
use time
use io
!)@(#*$&%^ ./rainbow2-a
#!/lang/b

Main()
	paper(1280, 800, black)

	let(dt, angle2rad(1))
	dt = dt

	int R = hypot(1280/2, 800/2)

	int *a = Nalloc(int, (R*2+1) * (R*2+1))
	int *d = Nalloc(int, (R*2+1) * (R*2+1))
#	int a[R*2+1][R*2+1]
#	int d[R*2+1][R*2+1]
	colour rb[360]
	int np[R*2+1]

	for(i, 0, 360)
		rb[i] = rainbow(i)

	for(y, -R, R)
		let(X, (int)notpot(R, y))
		np[y+R] = X
		for(x, -X, X)
#			d[x+R][y+R] = hypot(x, y)
			d[ix(x,y)] = hypot(x, y)
			let(A, Atan2(y, x))
#			a[x+R][y+R] = mod(((int)A), 360)
			a[ix(x,y)] = mod(((int)A), 360)

	let(da, 0.0)

	int first = 1
	wheel()
	Paint()
	Sleep(3)

	first = 0

	repeat
		wheel()
		Paint()
		#spin()
		#da -= 5
		da -= 8
		first = 0

def ix(x,y) (x+R) + (y+R) * (R*2+1)

def wheel()
	.
#		for(i, 0, 360)
#			rb[i] = rainbow(i)
		for(y, -R, R)
			let(X, np[y+R])
			for(x, -X, X)
				if Rand() < 0.02 || first
#					let(A, (a[x+R][y+R] + d[x+R][y+R]))
					let(A, (a[ix(x,y)] + d[ix(x,y)]))
					if toss() || first
						A = mod(A*2+da/2, 360)
					else
						A = mod(A*3+da, 360)
					col(rb[A])
					point(x, y)

def spin()
	rb_red_angle += 1.6*dt
	rb_green_angle += 2*dt
	rb_blue_angle += -1*dt

use main
use m
use gr
use error
use time
use io
!)@(#*$&%^ ./roses
#!/lang/b

use b

rose(int x, int y, int r0, int a0, int da0, int petals, num cola, num red0, num redr, num reda, num green0, num greenr, num greena, num blue0, num bluer, num bluea)
	num a, ca, pr, r
	num da = 360.0/petals
	for r=r0; r>0; r-=(r+20)/25
		pr = r * 7.0/6
		for a=a0; a<358+a0; a+=da
			ca = (r0-r) / r0 * cola
			rgb(red0+redr*Cos(ca+reda), green0+greenr*Cos(ca+greena), blue0+bluer*Cos(ca+bluea))
			circle_fill(Sin(a)*r + x, Cos(a)*r + y, pr)
		a0 += da0

num rot

roses()
	int i, x, y
	int n = 9
	int nc = 3
	int j
	num da = 360.0/n
	num a
	rgb(.1, 0, .2)
	clear()
	rose(0, 0, 65, 30 + rot, 47, 4, 360,       .9, .1, 0,  .5, .1, 180,  .5, .1, 180)
	for i=0; i<n; ++i
		j = i / nc
		a = i*da + 40 - rot
		x = 225*Sin(a)
		y = 225*Cos(a)
		rose(x, y, 30, -60+a + rot*5, 37, 6, c[j][0], c[j][1], c[j][2], c[j][3], c[j][4], c[j][5], c[j][6], c[j][7], c[j][8], c[j][9])
	Paint()

num c[3][10] =
		180,  .9, .1, 0,  .5, .1, 0,  .4, .1, 180
	,
		180,  .7, .1, 0,   0,  0, 0,  .2, .2, 180
	,
		220,  .5, .1, 120,  .7, .2, 120,  .7, .2, -60

main()
	space()
	yflip()

	for rot = 0; rot <= 360; ++rot
		roses()
		Paint()
!)@(#*$&%^ ./shinytext/1
#!/lang/b
use b
num r1, r2
num rt3
num whiteness

Main()
	rt3 = sqrt(3.0)

#	space(640, 480)
	space()
	gprint_anchor(0, 0)

	cstr s = fortune()
	int fs = font_size_to_fit(s)

	repeat(50)
		col(rb[randi(0,360)])
		font("helvetica-medium", fs/randi(2, 5))
		move(randi(-w_2, w_2), randi(-h_2, h_2))
		gsayf(s)

	font("helvetica-bold", fs)
	col(white)
	move(0, 0)
	gsayf(s)

	if !vid
		error("xshm pixmaps are not working")

	if depth <= 16
		warn("shinytext works best in true colour, not %d bit colour", depth)

	with_pixel_type(shiny)

#def shiny(pixel_type, depth)
#	shiny1(pixel_type, r^^depth, g^^depth, b^^depth, fastrgb^^depth)

#def shiny1(pixel_type, r, g, b, rgb)

cstr fortune()
	cstr s = args ? join(' ', arg) : cmd("fortune -s -n 40")
	if !s || !*s
		s = "Hello World"
	return s

int font_size_to_fit(cstr s)
	font("helvetica-medium", 200)
	num tw = text_width(s)
	int fs = (int)(200*w/tw * 0.90)
	font("helvetica-medium", fs)
	return fs

def shiny(pixel_type)
	int c = 0
	colour cl = white
	repeat
		font("helvetica-bold", fs)
		int m = ++c % 100
		if m == 0
			cl = white
		 eif m == 50
			cl = rb[randi(0, 360)]
		if Rand() < 0.3
			col(rb[randi(0,360)])
			font("helvetica-medium", fs/randi(2, 5))
			move(randi(-w_2, w_2), randi(-h_2, h_2))
			gsayf(s)
			Paint()
		if m == 0 || m == 50
			s = fortune()
			fs = font_size_to_fit(s)
			col(cl)
			font("helvetica-bold", fs)
			move(0, 0)
			gsayf(s)
		pixel_type *px = (pixel_type *)pixel(vid, 1, 1)
		for(y, 1, h-1)
			for(x, 1, w-1)
				pixel_type o
				o=*px
				pixel_type x0=px[-1], x1=px[1], y0=px[-w], y1=px[w]
#				if o == 0 || Rand() < 0.5
				if 1
					o = fastrgb32(
					 fn(r(o), r(x0), r(x1), r(y0), r(y1)),
					 fn(g(o), g(x0), g(x1), g(y0), g(y1)),
					 fn(b(o), b(x0), b(x1), b(y0), b(y1)))
				if Rand() < 0.8 || x<4 || y<4 || x>w-5 || y>h-5
					px[-w-1] = o
				 else
					px[-w-1] = px[randi(-4, 5) + randi(-4, 5)*w]
				++px
			px += 2
		back(y, h-1, 1)
			px -= 2
			back(x, w-1, 1)
				--px
				*px = px[-w-1]

		black()
		rect(-w_2, -h_2, w, h)

		Paint()

# assuming 32 bit colour again:
def r(x) x >> 16 & 0xFF
def g(x) x >> 8 & 0xFF
def b(x) x & 0xFF

def fastrgb32(r0, g0, b0) (long)r0<<16 | (long)g0<<8 | (long)b0

def fnp 3
#def fn(o, x0, x1, x2, x3) iclamp(pow(avg(pow(o, fnp), pow(x0, fnp), pow(x1, fnp), pow(x2, fnp), pow(x3, fnp)), 1.0/fnp)*1.001, 0, 255)

#def fn(o, x0, x1, x2, x3) iclamp(toss() ? avg(o, x0, x1, x2, x3) : max(o, x0, x1, x2, x3)*0.8, 0, 255)
def fn(o, x0, x1, x2, x3) avg(o, x0, x1, x2, x3)
!)@(#*$&%^ ./show
#!/lang/b
use b

num margins = 40
int font_ref = 200
num effect_duration = 1
boolean step_by_step = 1
boolean effects = 1
num delay = 0, delay_demo = 0, delay_page = 0
cstr demos_dir = "."
boolean loop = 0
boolean smooth = 1
int smooth_steps = 30
int smooth_dur = 0.50
def smooth_delay smooth_dur / smooth_steps
num x_expose_delay = 0.2

num old_y, old_font_size, old_height
boolean start_of_page = 1

int page = 0

def usage()
	usage("slides_file [start_page]")

Main():
	int start_page = 0

	if *Getenv("quick")
		step_by_step = 0
	if *Getenv("nofx")
		effects = 0
	if *Getenv("nosmooth")
		smooth = 0
	demos_dir = Getenv("demos", demos_dir)
	delay = atof(Getenv("delay", "0"))
	delay_demo = atof(Getenv("delay_demo", "0"))
	delay_page = atof(Getenv("delay_page", "0"))
	if delay && !delay_demo
		delay_demo = delay * 4
	if delay && !delay_page
		delay_page = delay * 4
	if *Getenv("loop")
		loop = 0

	args(cstr, slides_file)
	getargs(int, start_page)

	dirbasename(slides_file, dir, base)
	Chdir(dir)
	slides_file = base

	gr_exit = 1
	fullscreen_grab_keyboard = 0  # for now, uses terminal
	space()
	gprint_anchor(-1, 1)
	csleep(smooth_delay)

	new(lines, vec, cstr, 16)

	repeat
		vec_clear(lines)
		tofree_block()
			F_in(slides_file):
				warn("%d", page)
				show_slides(lines, start_page)
		if !loop
			break

show_slides(vec *lines, int start_page)
	eachline(l):
		boolean show = page >= start_page
		boolean end_of_page = *l == ''

		if *l == '!'
			if show
				run_demo(l+1)
		 eif *l == '<'
			F_in(tofree(format("%s/%s", demos_dir, l+1)))
				show_slides(lines, start_page)
		 else
		 	if !end_of_page
				vec_push(lines, Strdup(l))

			if show
				if end_of_page
					if !step_by_step
						show_slide(lines)
					do_delay(delay_page)
					if effects
						effect()
				 eif (step_by_step && *l)
					show_slide(lines)
					do_delay(delay)

			if end_of_page
				++page
				warn("%d", page)
				vec_clear(lines)
				start_of_page = 1

show_slide(vec *lines):
	int n = veclen(lines)
	font("helvetica-medium", font_ref)
	num height = font_height()
	num max_width = 0
	for_vec(l, lines, cstr):
		max_width = nmax(max_width, text_width(*l))
	num x_scale = (w - margins) / max_width
	num y_scale = (h - margins) / (height * n)
	num scale = nmin(x_scale, y_scale)
	num font_size = font_ref * scale
	height *= scale
	
	num y = height * n / 2

	if smooth && !start_of_page
		for(i, 0.0, 1.0, 1.0/smooth_steps)
			num y1 = blend(i, old_y, y)
			num font_size1 = blend(i, old_font_size, font_size)
			num height1 = blend(i, old_height, height)
			draw_lines(lines, y1, font_size1, height1)
			csleep(smooth_delay)

	draw_lines(lines, y, font_size, height)

	old_y = y
	old_font_size = font_size
	old_height = height

	start_of_page = 0

draw_lines(vec *lines, num y, num font_size, num height)
	font("helvetica-medium", font_size)
	clear()
	white()
	for_vec(l, lines, cstr):
		move(-w_2 + margins/2, y)
		gsayf(*l)
		y -= height
	Paint()

effect():
	with_pixel_type(effect)

def effect(pixel_type):
	num time = rtime()
	which page % 4:
	0	for int i=0; ; ++i:
			pixel_type *px = pixel()
			long x, y
			for y=-h_2; y<h_2; ++y:
				for x=-w_2; x<w_2; ++x:
					if toss() && x>-w_2 && x<w_2-1 && y>-h_2+1 && y<h_2-1:
						*px = px[toss()*2-1 + toss()*3*w-2*w]
						if *px:
							*px -= 0x0202
					++px
			if i % 10:
				Paint()
			effect_stop()
	1	black()
		for int i=0; ; ++i:
			circle(randi(-w_2, w_2), randi(-h_2, h_2), randi(h_2))
			if i % 10 == 0:
				Paint()
			if i % 100 == 0:
				hsv(i/3000.0 * 360 * 2, Sin(180*i/3000.0)/2, 0)
			effect_stop()
	2	for int i=0; ; ++i:
			pixel_type *px = pixel()
			long x, y
			colour c = hsv(i/100.0 * 360, 1-(i/100.0), 1-(i/100.0))
			for y=-h_2; y<h_2; ++y:
				for x=-w_2; x<w_2; ++x:
					if *px
						*px = c
					++px
			Paint()
			effect_stop()
	3	black()
		for int i=0; ; ++i
			hsv(i/100.0 * 360, 1-(i/100.0), 0)
			circle_fill(randi(w)-w_2, randi(h)-h_2, randi(10, 100))
			if i % 3 == 0
				Paint()
			effect_stop()

run_demo(cstr file)
	int child = Fork()
	if child == 0
		Close(3)
		Execl(format("%s/%s", demos_dir, file), NULL)
	do_delay(delay_demo)
	kill(child, SIGTERM)
	Child_wait()
	Sleep(x_expose_delay)
#	handle_events()

def effect_stop():
	if i % 10 && rtime() > time+effect_duration:
		break
!)@(#*$&%^ ./tree/windy.b
use tree
use m

Main()
	int forks = 6
	num speed = 0.2

	switch args
	2	speed = atof(arg[1])
	1	forks = atoi(arg[0])
	0	break
	else	usage("[forks [speed]]")

	paper(640, 480, coln("tan"))

	num a0 = 36, a1 = -43
	num da0 = 0, da1 = 0
	num drag = 0.995

	num m0 = .77, m1 = .80

	boolean limit = 0

	repeat
		clear()
		tree(forks, 0, -200, 100, 90, a0, a1, m0, m1)
		Paint()

		a0 += da0 ; a1 += da1
		da0 += Rand(-speed, speed) ; da1 += Rand(-speed, speed)
		if limit
			if a0 < 10
				da0 += .3
			eif a0 > 60
				da0 -= .3
			if a1 < -60
				da1 += .3
			eif a1 > -10
				da1 -= .3
		
			da0 *= drag ; da1 *= drag

		Sleep(0.02)

use headers
