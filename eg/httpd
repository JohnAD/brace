#!/lang/b

use b

cstr listen_addr = "0.0.0.0"
int listen_port = 80
cstr listen_addr_stunnel = "127.0.0.1"
int listen_port_stunnel = 81
cstr www_root = "/www"
cstr default_user = "www-data"
cstr default_host = "default"

def max_line_length 2048

hashtable *users

def verbose warn

Main()
	uid_t uid = geteuid()
	if uid != 0
		error("%s must be run as root", program)

	ignore_pipe()

	users = load_passwd()

	sched_init()

	new(l, listener_tcp, listen_addr, listen_port)
	new(w, httpd_launcher)
	sh(sock_p, l, w)
	start(l) ; start(w)

	if listen_addr_stunnel && listen_port_stunnel
		new(l_https, listener_tcp, listen_addr_stunnel, listen_port_stunnel)
		new(w_https, httpd_launcher)
		sh(sock_p, l_https, w_https)
		start(l_https) ; start(w_https)

	run()

proc httpd_launcher()
	port sock_p in
	state sock_p sk
	repeat
		rd(in, sk)
		New(s, httpd, sk)
		start(s)

proc httpd(sock *sk)
	port buffer in
	port buffer out
	port buffer fin
	state int fd = sk->fd
	state reader r
	state reader fr
	state writer w
	state cstr method = NULL
	state cstr url = NULL
	state cstr proto = NULL
	state cstr host = NULL
	state cstr path = NULL
	state cstr scheme = "http"
	state cstr root = NULL
	state cstr fullpath = NULL
	state cstr user = default_user
	state cstr pass = NULL
	state off_t reqlen = 0
	state int file_fd = -1
	state passwd *u
	state int code
	state cstr msg
	state cstr location
<<<<<<< HEAD:eg/httpd
	state boolean keep_alive = 1
	state boolean statable
=======
	state sockaddr_in sockname
	state socklen_t namelen
	state int private = 0
	state int expire_already = 0
	state cstr user_agent = NULL

	if getsockname(fd, &sockname, &namelen) == 0
		if sockname.sin_family == AF_INET
			int port = ntohs(sockname.sin_port)
			if listen_addr_stunnel && port == listen_port_stunnel
				scheme = "https"
	
>>>>>>> 908c467fe1928d9efffc21cbc19ba3c0117dde56:eg/httpd

	init(&r, reader, fd)
	init(&w, writer, fd)

	sh(buffer, &r, This)
	sh(buffer, This, &w)

	init(&in, buffer, block_size)
	init(&out, buffer, block_size)

	start(&r) ; start(&w)

	# read_method_url_proto

	cstr s
req	do
		breadln(in)
		if !buflen(&in)
			quit
		s = buf0(&in)
	 while !*s
	size_t l = strlen(s)+1
	cstr_dos_to_unix(s)
	cstr *words = split(s, ' ')
	if arylen(words) != 3
		bad
	method = strdup(words[0]) ; url = strdup(words[1]) ; proto = strdup(words[2])
#	verbose("%s %s %s", method, url, proto)
	Free(words)
	buffer_shift(&in, l)

	# check proto
	if !strncmp(proto, "HTTP/", 5)
		if atof(proto+5) < 1.1
			keep_alive = 0

	# read_headers

	repeat
		breadln(in)
		if !buflen(&in)
			quit
		cstr s = buf0(&in)
		size_t l = strlen(s)+1
		cstr_dos_to_unix(s)
		if !*s
			break
#		verbose(s)
		cstr *words = split(s, ':', 2)
		if arylen(words) != 2
			bad
		while isspace(words[1][0])
			++words[1]
		if !strcasecmp(words[0], "Host")
			host = strdup(words[1])
		 eif !strcasecmp(words[0], "Authorization")
			if !strncasecmp(words[1], "Basic ", 6)
				decl(base64, buffer)
				buffer_from_cstr(base64, words[1]+6)
				new(o, buffer, 32)
				base64_decode_buffers(base64, o)
				user = buffer_to_cstr(o)
				cstr *user_pass = split(user, ':', 2)
				if arylen(user_pass) != 2
					Free(user_pass)
					bad
				pass = user_pass[1]
<<<<<<< HEAD:eg/httpd
		 eif !strcasecmp(words[0], "Content-Length")
			reqlen = atoi(words[1])
		 eif !strcasecmp(words[0], "Connection")
			if !strcasecmp(words[1], "close")
				keep_alive = 0
			 eif !strcasecmp(words[1], "Keep-Alive")
				keep_alive = 1
=======
		 eif !strcasecmp(words[0], "User-Agent")
			user_agent = strdup(words[1])
>>>>>>> 908c467fe1928d9efffc21cbc19ba3c0117dde56:eg/httpd
		Free(words)
		buffer_shift(&in, l)

	# read data if any. at the moment, the data is simply discarded
	if reqlen
		bread(in, reqlen)

	if host == NULL
		host = get_host_from_url(url)
	if host == NULL
		host = strdup(default_host)

	path = get_path_from_url(url)

	root = path_cat(www_root, host)

	if is_symlink(root)
		cstr realhost = readlinks(root, if_dead_path)
		location = format("%s://%s%s", scheme, base_name(realhost), path)
		Free(realhost)
		loc

	fullpath = path_cat(root, path)

	# redirect /index.html -> /  so each file has a single url
	if cstr_ends_with(url, "/index.html")
		location = strdup(url)
		strrchr(location, '/')[1] = '\0'
		loc

	if fullpath[strlen(fullpath)-1] == '/'
		cstr fullpath_index = path_cat(fullpath, "index.html")
		if is_file(fullpath_index)
			Free(fullpath)
			fullpath = fullpath_index

	fullpath = path_tidy(fullpath)
	unless(cstr_begins_with(fullpath, root) && fullpath[strlen(root)] == '/')
		bad

	if strstr(fullpath, "/.")
		bad

	verbose("%s %s", method, fullpath)

	# set user and respond

	u = get(users, user)

	if user != default_user && !(u && pass && auth(u, pass))
		reqauth
		# FIXME incorrect password message / request auth

	if pass
		bzero(pass, strlen(pass))

	# TODO use try if it works?

	Seteuidgid(u)
	  # must reset this to root before yielding! a bit ugly

	decl(st, stats)
	statable = !stat(fullpath, st)

	if !statable
		int errno_stat = errno
		Seteuidgid_root()
		if errno_stat == EACCES
			reqauth
		notf

	if !(st->st_mode & S_IROTH)
		private = 1
		if !user_agent || strcasestr(user_agent, "MSIE") || !strcasestr(user_agent, "Mozilla/5.0")
			expire_already = 1

	if S_ISREG(st->st_mode)
		# TODO CGI, if authorized
		file_fd = open(fullpath, O_RDONLY)
		Seteuidgid_root()
		if file_fd == -1
			if errno == EACCES
				reqauth
			srv_er
		nonblock(file_fd)
		add_fd(file_fd)

		bsay(out, "HTTP/1.1 200 OK\r")
		bsayf(out, "Content-Length: %lld\r", (long long int)st->st_size)
		if expire_already
			expire_already_headers()
		bcrlf(out)

		init(&fr, reader, file_fd)
		sh(buffer, &fr, out, This, fin)
		init(&fin, buffer, block_size)
		start(&fr)

		repeat
			pull(fin)
			if !buflen(&fin)
				break
			bwrite(out, buffer_range(&fin)) # FIXME don't copy data
			bflush(out)
			if buflen(&out) # error
				break
			buffer_clear(&fin)
			push(fin)

		buffer_free(&fin)
		if file_fd != -1
			rm_fd(file_fd)
			close(file_fd)
		again

	 eif S_ISDIR(st->st_mode)
		if fullpath[strlen(fullpath)-1] != '/'
			Seteuidgid_root()
			location = format("%s/", url)
			loc
		 else
			new(path_esc, buffer, 64)
			sh_quote(fullpath, path_esc)
			cstr command = format("ls -1F %s", buffer_to_cstr(path_esc))
			buffer_free(path_esc)
			state cstr ls = cmd(command)
			Free(command)
			Seteuidgid_root()
			bsay(out, "HTTP/1.1 200 OK\r")
<<<<<<< HEAD:eg/httpd
			bsayf(out, "Content-Length: %d\r", strlen(ls))
=======
			if expire_already
				expire_already_headers()
>>>>>>> 908c467fe1928d9efffc21cbc19ba3c0117dde56:eg/httpd
			bcrlf(out)
			bprint(out, ls)
			bflush(out)
			Free(ls)
			again

	 else
		Seteuidgid_root()
		notf

	fault("this code should not be reached")

again	Free(method) ; Free(url) ; Free(proto) ; Free(host)
	Free(root) ; Free(fullpath)
	if keep_alive
		req
	quit

quit	rm_fd(fd)
	sock_free(sk)
	Free(This)
	stop

error	bsayf(out, "HTTP/1.1 %d %s\r", code, msg)
	msg = format("httpd: %d %s\r\n  %s %s\r\n", code, msg, method, fullpath)
	lenmsg

lenmsg	bsayf(out, "Content-Length: %d\r", strlen(msg))
	bcrlf(out)
	bprint(out, msg)
	Free(msg)
	bflush(out)
	again

bad	code = 400 ; msg = "Bad Request"
	error

notf	code = 404 ; msg = "Not Found"
	error

srv_er	code = 500 ; msg = "Internal Server Error"
	error

reqauth	if !cstr_eq(scheme, "https")
		https
	bsay(out, "HTTP/1.1 401 Unauthorized\r")
	bsayf(out, "WWW-Authenticate: Basic realm=\"%s\"", host)
	msg = format("httpd: Unauthorized\r\n  %s %s\r\n", method, fullpath)
	lenmsg

loc	bsay(out, "HTTP/1.1 301 Moved Permanently\r")
	bsayf(out, "Location: %s", location)
<<<<<<< HEAD:eg/httpd
	msg = format("httpd: redirected to %s\r\n", location)
	Free(location)
	lenmsg
=======
	bcrlf(out)
	bsayf(out, "httpd: redirected to %s\r", location)
	bflush(out)
#	verbose("    %s", location)
	Free(location)
	quit

https	location = format("https://%s%s", host, path)
	loc

def expire_already_headers()
	bsay(out, "Cache-Control: private, no-cache, no-store")
	bsay(out, "Expires: 0")
>>>>>>> 908c467fe1928d9efffc21cbc19ba3c0117dde56:eg/httpd
