#!/lang/b

use b

cstr listen_addr = "0.0.0.0"
int listen_port = 80
cstr listen_addr_stunnel = "127.0.0.1"
int listen_port_stunnel = 81
cstr www_root = "/www"
cstr default_user = "www-data"
cstr default_host = "default"

def max_line_length 2048

hashtable *users

def verbose warn

Main()
	uid_t uid = geteuid()
	if uid != 0
		error("%s must be run as root", program)

	Sigdfl_all()

	block_size = 16*1024

	date_rfc1123_init()
	load_mimetypes()

	ignore_pipe()

	users = load_passwd()

	sched_init()

	new(l, listener_tcp, listen_addr, listen_port)
	new(w, httpd_launcher)
	sh(sock_p, l, w)
	start(l) ; start(w)

	if listen_addr_stunnel && listen_port_stunnel
		new(l_https, listener_tcp, listen_addr_stunnel, listen_port_stunnel)
		new(w_https, httpd_launcher)
		sh(sock_p, l_https, w_https)
		start(l_https) ; start(w_https)

	run()

proc httpd_launcher()
	port sock_p in
	state sock_p sk
	repeat
		rd(in, sk)
		New(s, httpd, sk)
		start(s)

proc httpd(sock *sk)
	port buffer in
	port buffer out
	port buffer fin

	state int fd = sk->fd
	state reader r
	state reader fr
	state writer w
	state sockaddr_in sockname
	state socklen_t namelen = sizeof(sockaddr_in)
	state cstr scheme = "http"

	if getsockname(fd, &sockname, &namelen) == 0
		if sockname.sin_family == AF_INET
			int port = ntohs(sockname.sin_port)
			if listen_addr_stunnel && port == listen_port_stunnel
				scheme = "https"

	init(&r, reader, fd)
	init(&w, writer, fd)

	sh(buffer, &r, This)
	sh(buffer, This, &w)

	init(&in, buffer, block_size)
	init(&out, buffer, block_size)

	start(&r) ; start(&w)

	# read_method_url_proto

req	state cstr s
	state size_t l
	state cstr method = NULL
	state cstr url = NULL
	state cstr proto = NULL
	state cstr host = NULL
	state cstr path = NULL
	state cstr root = NULL
	state cstr fullpath = NULL
	state cstr user = default_user
	state cstr pass = NULL
	state off_t reqlen = 0
	state int file_fd = -1
	state passwd *u
	state int code
	state cstr msg
	state cstr location
	state int private = 0
	state int expire_already = 0
	state cstr user_agent = NULL
	state boolean keep_alive = 1
	state boolean statable
	decl(st, Stats)
	state float proto_f = 0
	state cstr body = NULL
	state time_t modified = -1
	state cstr mtype = "text/plain"
	state int status

	repeat
		breadln(in)
		if !buflen(&in)
			quit
		s = buf0(&in)
		l = strlen(s)+1
		cstr_dos_to_unix(s)
		if *s
			break
		buffer_shift(&in, l)

	cstr *words = split(s, ' ')
	if arylen(words) != 3
		bad
	method = strdup(words[0]) ; url = strdup(words[1]) ; proto = strdup(words[2])
	url_decode(url)
	verbose("%s %s %s", method, url, scheme)
	Free(words)
	buffer_shift(&in, l)

	# check proto
	if !strncmp(proto, "HTTP/", 5)
		proto_f = atof(proto+5)
		if num_lt(proto_f, 1.1)
			keep_alive = 0

	# read_headers

	repeat
		breadln(in)
		if !buflen(&in)
			quit
		s = buf0(&in)
		l = strlen(s)+1
		cstr_dos_to_unix(s)
		if !*s
			buffer_shift(&in, l)
			break
		#verbose(s)
		cstr *words = split(s, ':', 2)
		if arylen(words) != 2
			bad
		while isspace(words[1][0])
			++words[1]
		if !strcasecmp(words[0], "Host")
			host = strdup(words[1])
		 eif !strcasecmp(words[0], "Authorization")
			if !strncasecmp(words[1], "Basic ", 6)
				decl(base64, buffer)
				buffer_from_cstr(base64, words[1]+6)
				new(o, buffer, 32)
				base64_decode_buffers(base64, o)
				user = buffer_to_cstr(o)
				cstr *user_pass = split(user, ':', 2)
				if arylen(user_pass) != 2
					Free(user_pass)
					bad
				pass = user_pass[1]
		 eif !strcasecmp(words[0], "User-Agent")
			user_agent = strdup(words[1])
		 eif !strcasecmp(words[0], "Content-Length")
			reqlen = atoi(words[1])
		 eif !strcasecmp(words[0], "Connection")
			if !strcasecmp(words[1], "close")
				keep_alive = 0
			 eif !strcasecmp(words[1], "Keep-Alive")
				keep_alive = 1
		Free(words)
		buffer_shift(&in, l)

	if host == NULL
		host = get_host_from_url(url)
	if host == NULL
		host = strdup(default_host)

	path = get_path_from_url(url)

	root = path_cat(www_root, host)

	if is_symlink(root)
		cstr realhost = readlinks(root, if_dead_path)
		location = format("%s://%s%s", scheme, base_name(realhost), path)
		Free(realhost)
		loc

	fullpath = path_cat(root, path)

	fullpath = path_tidy(fullpath)
	unless(cstr_begins_with(fullpath, root) && fullpath[strlen(root)] == '/')
		bad

	if strstr(fullpath, "/.")
		forbid

	# redirect /index.html -> /  so each file has a single url
	if cstr_ends_with(url, "/index.html")
		location = strdup(url)
		strrchr(location, '/')[1] = '\0'
		loc

	if fullpath[strlen(fullpath)-1] == '/'
		cstr fullpath_index = path_cat(fullpath, "index.html")
		if is_file(fullpath_index)
			Free(fullpath)
			fullpath = fullpath_index

	#verbose("  %s", fullpath)

	# set user and respond

	u = get(users, user)

	if user != default_user && !(u && pass && auth(u, pass))
		reqauth
		# FIXME incorrect password message / request auth

	if pass
		bzero(pass, strlen(pass))

	# TODO use try if it works?

	Seteuidgid(u)
	  # must reset this to root before switching! a bit ugly

	statable = !stat(fullpath, st)

	if !statable
		Seteuidgid_root()
		accerr

	if !(st->st_mode & S_IROTH)
		private = 1
		if !user_agent || strcasestr(user_agent, "MSIE") || !strcasestr(user_agent, "Mozilla/5.0")
			expire_already = 1

	if S_ISREG(st->st_mode) && st->st_mode & S_IXUSR
		serve_cgi()
	 eif reqlen
		Seteuidgid_root()
		bad
	 eif S_ISREG(st->st_mode)
		serve_file()
	 eif S_ISDIR(st->st_mode)
		serve_dir()
	 else
		Seteuidgid_root()
		notf

done	Free(method) ; Free(url) ; Free(proto) ; Free(host)
	Free(root) ; Free(fullpath) ; Free(body)
	if keep_alive
		req
	quit

quit	verbose("")
	rm_fd(fd)
	sock_free(sk)
	Free(This)
	stop

error	body = format("httpd: %d %s\r\n", code, msg)
	headers(code, msg, strlen(body))
	bodymsg

bodymsg	discard_req()
	bcrlf(out)
	bprint(out, body)
	bflush(out)
	if buflen(&out) # error
		keep_alive = 0
	done

bad	code = 400 ; msg = "Bad Request"
	error

forbid	code = 403 ; msg = "Forbidden"
	error

notf	code = 404 ; msg = "Not Found"
	error

srverr	code = 500 ; msg = "Internal Server Error"
	error

reqauth	if !cstr_eq(scheme, "https")
		https
	body = format("httpd: 401 Unauthorized\r\n", method)
	headers(401, "Unauthorized", strlen(body))
	bsayf(out, "WWW-Authenticate: Basic realm=\"%s\"", host)
	bodymsg

loc	body = format("httpd: redirected to %s\r\n", location)
	headers(301, "Moved Permanently", strlen(body))
	bsayf(out, "Location: %s", location)
	verbose("  %s", location)
	Free(location)
	bodymsg

https	location = format("https://%s%s", host, path)
	loc

accerr	which errno
	EACCES	reqauth
	EPERM	reqauth
	ENOENT	notf
	ENOTDIR	notf
	ENAMETOOLONG	bad
	else	srverr

def headers(code, msg, size)
	bsayf(out, "HTTP/1.1 %d %s\r", code, msg)
	bsayf(out, "Date: %s", date_rfc1123((time_t)sched->now))
	if modified != -1
		bsayf(out, "Last-Modified: %s", date_rfc1123(modified))
	bsayf(out, "Content-Length: %lld\r", (long long int)size)
	if code == 200 && expire_already
		bsay(out, "Cache-Control: private, no-cache, no-store")
		bsay(out, "Expires: 0")
	bsayf(out, "Content-Type: %s\r", mtype)
	bsayf(out, "Server: httpd")
	if num_lt(proto_f, 1.1)
		bsayf(out, "Connection: %s", keep_alive ? "Keep-Alive" : "close")

def serve_file()
	cstr base = strrchr(fullpath, '/')
	cstr ext = strrchr(base, '.')
	if ext++
		cstr _mtype = mimetype(ext)
		if _mtype
			mtype = _mtype

	file_fd = open(fullpath, O_RDONLY)
	Cloexec(fd)

	Seteuidgid_root()

	if file_fd == -1
		accerr
	nonblock(file_fd)
	add_fd(file_fd)

	modified = st->st_mtime
	headers(200, "OK", st->st_size)
	bcrlf(out)

	init(&fr, reader, file_fd)
	sh(buffer, &fr, out, This, fin)
	init(&fin, buffer, block_size)
	start(&fr)

	repeat
		pull(fin)
		if !buflen(&fin)
			break
		bwrite(out, buffer_range(&fin)) # FIXME don't copy data
		bflush(out)
		if buflen(&out) # error
			keep_alive = 0
			break
		buffer_clear(&fin)
		push(fin)

	buffer_free(&fin)
	if file_fd != -1
		rm_fd(file_fd)
		close(file_fd)

def serve_dir()
	if fullpath[strlen(fullpath)-1] != '/'
		Seteuidgid_root()
		location = format("%s/", url)
		loc

	vec *v = slurpdir(fullpath)  # TODO use d_type
	Seteuidgid_root()

	if !v
		accerr
	# loaded directory ok, root can stat the nodes
	sort_vec(v, cstrp_cmp)
	new(dirs, buffer, 256)
	new(files, buffer, 256)
	for_vec(i, v, cstr)
		if (*i)[0] == '.'
			continue
		cstr entpath = path_cat(fullpath, *i) # or chdir
		int dir = is_dir(entpath)
		cstr line
		if dir
			line = format("<a href=\"%s/\"><b>%s</b>/</a><br>\n", *i, *i)
			buffer_cat_cstr(dirs, line)
		 else
			line = format("<a href=\"%s\">%s</a><br>\n", *i, *i)
			buffer_cat_cstr(files, line)
		Free(line) ; Free(entpath) ; Free(*i)

	vec_free(v)

	buffer_cat_cstr(dirs, "<br>")
	buffer_cat_cstr(files, "<br>")

	buffer_nul_terminate(dirs)
	buffer_nul_terminate(files)

	modified = st->st_mtime
	headers(200, "OK", buflen(dirs)+buflen(files))
	mtype = "text/html"
	bcrlf(out)
	bwrite(out, buffer_range(dirs))
	bwrite(out, buffer_range(files))
	buffer_free(dirs)
	buffer_free(files)
	bflush(out)
	if buflen(&out) # error
		keep_alive = 0

def serve_cgi()
	pid_t child = Fork()
	if child == 0
		# I would like to be able to just Dup2() the file descriptors
		# to the CGI script and then forget about it. But some data was
		# buffered from the request already.

		# I could pass the data that was already buffered in an
		# argument or env variable, but that is non-standard.

		# I'll put the first part of the body which was read already in
		# REQUEST_BDDY_1
		buffer_nul_terminate(&in)
		Setenv("REQUEST_BDDY_1", buf0(&in))
		bufclr(&in)

		Dup2(fd, STDIN_FILENO)
		Dup2(fd, STDOUT_FILENO)

		# TODO set standard CGI environment

		Sigdfl(SIGPIPE)
		Execl(fullpath, fullpath, NULL)

	Seteuidgid_root()

	# dodgy apparently I need to indent this because in a macro
	.
		waitchild(child, status)

	if status_execfailed(status)
		accerr
	 eif status != 0
		# failed, or killed by signal
		# There might have been some output already
		# or the input might not be fully read.
		keep_alive = 0
		srverr
	 else
		# okay
		# No keep_alive for CGI at the moment.
		keep_alive = 0

def discard_req()
	# read request if any and discard it
	# FIXME it should check if there is a POST / PUT method
	# TODO what if we have POST or PUT but no Content-Length -
	# read until EOF and no keep_alive?
	if reqlen
		verbose("  discarding request of length %lld", (long long int)reqlen)
		bread(in, reqlen)
		buffer_shift(&in, imin(reqlen, buflen(&in)))

