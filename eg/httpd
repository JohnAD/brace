#!/lang/b

use b

cstr listen_addr = "0.0.0.0"
int listen_port = 80
cstr listen_addr_stunnel = "127.0.0.1"
int listen_port_stunnel = 81
cstr www_root = "/www"
cstr default_user = "www-data"
cstr default_host = "default"

def max_line_length 2048

hashtable *users

def verbose warn

Main()
	uid_t uid = geteuid()
	if uid != 0
		error("%s must be run as root", program)

	block_size = 16*1024

	date_rfc1123_init()

	ignore_pipe()

	users = load_passwd()

	sched_init()

	new(l, listener_tcp, listen_addr, listen_port)
	new(w, httpd_launcher)
	sh(sock_p, l, w)
	start(l) ; start(w)

	if listen_addr_stunnel && listen_port_stunnel
		new(l_https, listener_tcp, listen_addr_stunnel, listen_port_stunnel)
		new(w_https, httpd_launcher)
		sh(sock_p, l_https, w_https)
		start(l_https) ; start(w_https)

	run()

proc httpd_launcher()
	port sock_p in
	state sock_p sk
	repeat
		rd(in, sk)
		New(s, httpd, sk)
		start(s)

proc httpd(sock *sk)
	port buffer in
	port buffer out
	port buffer fin

	state int fd = sk->fd
	state reader r
	state reader fr
	state writer w
	state sockaddr_in sockname
	state socklen_t namelen = sizeof(sockaddr_in)
	state cstr scheme = "http"

	if getsockname(fd, &sockname, &namelen) == 0
		if sockname.sin_family == AF_INET
			int port = ntohs(sockname.sin_port)
			if listen_addr_stunnel && port == listen_port_stunnel
				scheme = "https"

	init(&r, reader, fd)
	init(&w, writer, fd)

	sh(buffer, &r, This)
	sh(buffer, This, &w)

	init(&in, buffer, block_size)
	init(&out, buffer, block_size)

	start(&r) ; start(&w)

	# read_method_url_proto

req	state cstr s
	state size_t l
	state cstr method = NULL
	state cstr url = NULL
	state cstr proto = NULL
	state cstr host = NULL
	state cstr path = NULL
	state cstr root = NULL
	state cstr fullpath = NULL
	state cstr user = default_user
	state cstr pass = NULL
	state off_t reqlen = 0
	state int file_fd = -1
	state passwd *u
	state int code
	state cstr msg
	state cstr location
	state int private = 0
	state int expire_already = 0
	state cstr user_agent = NULL
	state boolean keep_alive = 1
	state boolean statable
	decl(st, stats)
	state float proto_f = 0
	state cstr body = NULL
	state time_t modified = -1

	repeat
		breadln(in)
		if !buflen(&in)
			quit
		s = buf0(&in)
		l = strlen(s)+1
		cstr_dos_to_unix(s)
		if *s
			break
		buffer_shift(&in, l)

	cstr *words = split(s, ' ')
	if arylen(words) != 3
		bad
	method = strdup(words[0]) ; url = strdup(words[1]) ; proto = strdup(words[2])
	url_decode(url)
	verbose("%s %s %s", method, url, scheme)
	Free(words)
	buffer_shift(&in, l)

	# check proto
	if !strncmp(proto, "HTTP/", 5)
		proto_f = atof(proto+5)
		if num_lt(proto_f, 1.1)
			keep_alive = 0

	# read_headers

	repeat
		breadln(in)
		if !buflen(&in)
			quit
		s = buf0(&in)
		l = strlen(s)+1
		cstr_dos_to_unix(s)
		if !*s
			buffer_shift(&in, l)
			break
		#verbose(s)
		cstr *words = split(s, ':', 2)
		if arylen(words) != 2
			bad
		while isspace(words[1][0])
			++words[1]
		if !strcasecmp(words[0], "Host")
			host = strdup(words[1])
		 eif !strcasecmp(words[0], "Authorization")
			if !strncasecmp(words[1], "Basic ", 6)
				decl(base64, buffer)
				buffer_from_cstr(base64, words[1]+6)
				new(o, buffer, 32)
				base64_decode_buffers(base64, o)
				user = buffer_to_cstr(o)
				cstr *user_pass = split(user, ':', 2)
				if arylen(user_pass) != 2
					Free(user_pass)
					bad
				pass = user_pass[1]
		 eif !strcasecmp(words[0], "User-Agent")
			user_agent = strdup(words[1])
		 eif !strcasecmp(words[0], "Content-Length")
			reqlen = atoi(words[1])
		 eif !strcasecmp(words[0], "Connection")
			if !strcasecmp(words[1], "close")
				keep_alive = 0
			 eif !strcasecmp(words[1], "Keep-Alive")
				keep_alive = 1
		Free(words)
		buffer_shift(&in, l)

	# read data if any. at the moment, the data is simply discarded
	if reqlen
		verbose("  reading request of length %lld", (long long int)reqlen)
		bread(in, reqlen)

	if host == NULL
		host = get_host_from_url(url)
	if host == NULL
		host = strdup(default_host)

	path = get_path_from_url(url)

	root = path_cat(www_root, host)

	if is_symlink(root)
		cstr realhost = readlinks(root, if_dead_path)
		location = format("%s://%s%s", scheme, base_name(realhost), path)
		Free(realhost)
		loc

	fullpath = path_cat(root, path)

	fullpath = path_tidy(fullpath)
	unless(cstr_begins_with(fullpath, root) && fullpath[strlen(root)] == '/')
		bad

	if strstr(fullpath, "/.")
		forbid

	# redirect /index.html -> /  so each file has a single url
	if cstr_ends_with(url, "/index.html")
		location = strdup(url)
		strrchr(location, '/')[1] = '\0'
		loc

	if fullpath[strlen(fullpath)-1] == '/'
		cstr fullpath_index = path_cat(fullpath, "index.html")
		if is_file(fullpath_index)
			Free(fullpath)
			fullpath = fullpath_index

	#verbose("  %s", fullpath)

	# set user and respond

	u = get(users, user)

	if user != default_user && !(u && pass && auth(u, pass))
		reqauth
		# FIXME incorrect password message / request auth

	if pass
		bzero(pass, strlen(pass))

	# TODO use try if it works?

	Seteuidgid(u)
	  # must reset this to root before yielding! a bit ugly

	statable = !stat(fullpath, st)

	if !statable
		Seteuidgid_root()
		accerr

	if !(st->st_mode & S_IROTH)
		private = 1
		if !user_agent || strcasestr(user_agent, "MSIE") || !strcasestr(user_agent, "Mozilla/5.0")
			expire_already = 1

	if S_ISREG(st->st_mode)
		# TODO CGI, if authorized
		file_fd = open(fullpath, O_RDONLY)
		Seteuidgid_root()
		if file_fd == -1
			accerr
		nonblock(file_fd)
		add_fd(file_fd)

		modified = st->st_mtime
		headers(200, "OK", st->st_size)
		bcrlf(out)

		init(&fr, reader, file_fd)
		sh(buffer, &fr, out, This, fin)
		init(&fin, buffer, block_size)
		start(&fr)

		repeat
			pull(fin)
			if !buflen(&fin)
				break
			bwrite(out, buffer_range(&fin)) # FIXME don't copy data
			bflush(out)
			if buflen(&out) # error
				keep_alive = 0
				break
			buffer_clear(&fin)
			push(fin)

		buffer_free(&fin)
		if file_fd != -1
			rm_fd(file_fd)
			close(file_fd)
		done

	 eif S_ISDIR(st->st_mode)
		if fullpath[strlen(fullpath)-1] != '/'
			Seteuidgid_root()
			location = format("%s/", url)
			loc
		 else
			vec *v = slurpdir(fullpath)  # TODO use d_type
			Seteuidgid_root()
			if !v
				accerr
			# loaded directory ok, root can stat the nodes
			sort_vec(v, cstrp_cmp)
			new(dirs, buffer, 256)
			new(files, buffer, 256)
			for_vec(i, v, cstr)
				if (*i)[0] == '.'
					continue
				cstr entpath = path_cat(fullpath, *i) # or chdir
				int dir = is_dir(entpath)
				cstr line
				if dir
					line = format("<a href=\"%s/\"><b>%s</b>/</a><br>\n", *i, *i)
					buffer_cat_cstr(dirs, line)
				 else
					line = format("<a href=\"%s\">%s</a><br>\n", *i, *i)
					buffer_cat_cstr(files, line)
				Free(line) ; Free(entpath)
			buffer_cat_cstr(dirs, "<br>")
			buffer_cat_cstr(files, "<br>")

			buffer_nul_terminate(dirs)
			buffer_nul_terminate(files)

			modified = st->st_mtime
			headers(200, "OK", buflen(dirs)+buflen(files))
			bsay(out, "Content-Type: text/html\r")
			bcrlf(out)
			bwrite(out, buffer_range(dirs))
			bwrite(out, buffer_range(files))
			buffer_free(dirs)
			buffer_free(files)
			bflush(out)
			if buflen(&out) # error
				keep_alive = 0
			done

	 else
		Seteuidgid_root()
		notf

	fault("this code should not be reached")

done	Free(method) ; Free(url) ; Free(proto) ; Free(host)
	Free(root) ; Free(fullpath) ; Free(body)
	if keep_alive
		req
	quit

quit	verbose("")
	rm_fd(fd)
	sock_free(sk)
	Free(This)
	stop

error	body = format("httpd: %d %s\r\n", code, msg)
	headers(code, msg, strlen(body))
	bodymsg

bodymsg	bcrlf(out)
	bprint(out, body)
	bflush(out)
	if buflen(&out) # error
		keep_alive = 0
	done

bad	code = 400 ; msg = "Bad Request"
	error

forbid	code = 403 ; msg = "Forbidden"
	error

notf	code = 404 ; msg = "Not Found"
	error

srv_er	code = 500 ; msg = "Internal Server Error"
	error

reqauth	if !cstr_eq(scheme, "https")
		https
	body = format("httpd: Unauthorized\r\n  %s %s\r\n", method, fullpath)
	headers(401, "Unauthorized", strlen(body))
	bsayf(out, "WWW-Authenticate: Basic realm=\"%s\"", host)
	bodymsg

loc	body = format("httpd: redirected to %s\r\n", location)
	headers(301, "Moved Permanently", strlen(body))
	bsayf(out, "Location: %s", location)
	verbose("  %s", location)
	Free(location)
	bodymsg

https	location = format("https://%s%s", host, path)
	loc

accerr	which errno
	EACCES	reqauth
	ENOENT	notf
	ENOTDIR	notf
	ENAMETOOLONG	bad
	else	srv_er

def headers(code, msg, size)
	bsayf(out, "HTTP/1.1 %d %s\r", code, msg)
	bsayf(out, "Date: %s", date_rfc1123((time_t)sched->now))
	bsayf(out, "Server: httpd")
	if modified != -1
		bsayf(out, "Last-Modified: %s", date_rfc1123(modified))
	bsayf(out, "Content-Length: %lld\r", (long long int)size)
	if code == 200 && expire_already
		bsay(out, "Cache-Control: private, no-cache, no-store")
		bsay(out, "Expires: 0")
	if num_lt(proto_f, 1.1)
		bsayf(out, "Connection: %s", keep_alive ? "Keep-Alive" : "close")
