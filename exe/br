#!/bin/sh -e
#  brace compiler

# some useful env variables you can set to 1:
#  BX_DEBUG
#  DEBUG
#  BRACE_STANDALONE
#  BR_FIX
#  BRACE_LINE_NUMBERS
#  BR_CLEAN
#  BRACE_PLAIN
#  OPTIMIZE    (set to desired -O level)

fail() {
	echo fatal: "$@" >&2
	exit 1
}

log_fix_exit() {
	cat "$LOG" >&2
	if [ -n "$BR_FIX" -a -t 0 -a -t 1 ]; then
		fix "$B"
		echo '^C to stop, enter to continue compiling'
		read line
		exit 123
	fi
	exit 1
}

export LDFLAGS LDLIBS CFLAGS CC BRACE_LANGUAGE


PROG=`basename "$0"`
if [ "$PROG" = "br" -o "$1" = "-b" ]; then
	BRACE_LANGUAGE=C
	b=b
elif [ "$PROG" = "bbr" -o "$1" = "-bb" ]; then
	BRACE_LANGUAGE=C++
	b=bb
fi
if [ "$1" = "-b" -o "$1" = "-bb" ]; then
	shift
fi
if [ "$BRACE_LANGUAGE" = C ]; then b=b; else b=bb; fi

[ -n "$1" ] || fail "syntax: ${b}r [-b|-bb] foo.$b [foo [cc/ld flags]]"

B="$1"
if [ "$MINGW" = 1 ]; then
	B=`echo "$B" | perl -pe 's{^([a-z]):(\\\\|/)?}{/$1/}i; s{\\\\}{/}g;'`
fi
shift
X="$1"

if perl -ne 'exit !m{^#!/lang/bb$}' "$B"; then
	BRACE_LANGUAGE=C++
fi


. brace_env


dirname="`dirname "$B"`"
basename="`basename "$B"`"
if [ -n "$X" -a "$X" = "${X#-}" ]; then
	shift
	X="${X%$EXE}$EXE"
else
	if [ -x "$B" ]; then
		X="$dirname/.$basename$EXE"
	else
		X="$B$EXE"
		[ "$X" = "$B" ] &&
			fail "please specify a name for the executable"
	fi
fi
XBAK="$dirname/.$basename.xbak$EXE"
B1="$dirname/.$basename.${b}1"
C="$dirname/.$basename.$c"
BBAK="$dirname/.$basename.bak"
BBAK2="$dirname/.$basename.bak2"
LOG="$dirname/.$basename.log"
rm -f "$B1" "$C" "$LOG"
if [ -n "$BR_DEBUG" ]; then echo "BRACE_USE=$BRACE_USE"; fi
if [ -n "$BR_DEBUG" ]; then echo \< "$B" brace_number_lines \| b2b1 \> "$B1"; fi
<"$B" brace_number_lines "$B" | b2b1 2>"$LOG" >"$B1" || log_fix_exit
if [ -n "$BR_DEBUG" ]; then echo \< "$B1" brace \> "$C"; fi
<"$B1" brace 2>>"$LOG" >"$C" || log_fix_exit


PID=$$
if [ -z "$BRACE_STANDALONE" ]; then
	if [ -n "$BR_DEBUG" ]; then echo "$CC" $CINCLUDE $CFLAGS $LDFLAGS "$@" -o"$X" "$C" $LDLIBS; fi
	( eval $CC $CINCLUDE $CFLAGS $LDFLAGS "$@" -o\"$X\" \"$C\" $BRACE_L_SO $LDLIBS || touch .cc_failed.$PID ) 2>&1
else
	if [ -n "$BR_DEBUG" ]; then echo "$CC" $CFLAGS $LDFLAGS "$@" -o"$X" "$C" $LDLIBS; fi
	( eval $CC $CFLAGS $LDFLAGS "$@" -o\"$X\" \"$C\" $LDLIBS || touch .cc_failed.$PID ) 2>&1
fi | perl -ne '
	BEGIN { $|=1; } /Each undeclared identifier is reported only once/ || /for each function it appears in/ || /Info: resolving/ || /auto-importing has been activated/ || /This should work unless it involves constant data structures referencing/ || /in statically linked applications requires at runtime the shared libraries from the glibc version used for linking/ || /^\s*$/ || do { s,(^[^.:]*\.(c|cc):),.build/$1,; print }
' >>"$LOG"

if [ -e .cc_failed.$PID ]; then
	rm .cc_failed.$PID
	log_fix_exit
elif [ -s "$LOG" ]; then
	cat "$LOG"
fi
if [ \! -s "$LOG" ]; then rm "$LOG"; fi
#if [ -z "$DEBUG" ]; then
#	strip -s "$X"
#fi
if [ -n "$BR_CLEAN" ]; then
	rm "$C" "$B1"
else
	rm -f "$XBAK" "$BBAK2"
	cp -a "$X" "$XBAK"
	if [ -e "$BBAK" ]; then
		mv "$BBAK" "$BBAK2"
	fi
	cp -a "$B" "$BBAK"
fi

exit 0
